---
title: "COV-BARRIER"
author: "A.Amstutz"
date: "2023-11-05"
output: 
  html_document:
    keep_md: yes
    toc: yes
    toc_float: yes
    code_folding: hide
  pdf_document:
    toc: yes
---

# Load packages
```{r load packages, echo=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
library(readxl)
library(writexl)
library(tableone)
library(haven) # Read sas files
library(here)
library(kableExtra)

library(jtools) # for summ() and plot_summs
library(sjPlot) # for tab_model
library(ggplot2) # survival/TTE analyses and other graphs
library(ggsurvfit) # survival/TTE analyses
library(survival) # survival/TTE analyses
library(gtsummary) # survival/TTE analyses
library(ggfortify) # autoplot
library(tidycmprsk) # competing risk analysis
library(ordinal) # clinstatus ordinal regression
library(logistf) # Firth regression in case of rare events

library(finalfit) # missing data exploration
library(mice) # multiple imputation
library(jomo) # multiple imputation
library(mitools) # multiple imputation
```

# Load Data
```{r, include=FALSE}
# SDTM_KHAA_final_new

# df_adverse_events <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/ae.sas7bdat")
# df_adverse_events_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppae.sas7bdat")
# df_clinclass <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/cc.sas7bdat")
# df_clinevent <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/ce.sas7bdat")
# df_comed <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/cm.sas7bdat")
# df_comed_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppcm.sas7bdat")
# df_demographics <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/dm.sas7bdat")
# df_demographics_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppdm.sas7bdat")
# df_disco <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/ds.sas7bdat")
# df_prot_dev <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/dv.sas7bdat")
# df_prot_dev_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppdv.sas7bdat")
# df_dose_details <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/ec.sas7bdat")
# df_dose_details_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppec.sas7bdat")
# df_dose_details2 <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/ex.sas7bdat")
# df_death_SE <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/fa.sas7bdat")
# df_death_SE_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppfa.sas7bdat")
# df_hosp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/ho.sas7bdat")
# df_lab <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/lb.sas7bdat")
# df_lab_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/supplb.sas7bdat")
# df_lab_ext <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/xl.sas7bdat")
# df_lab_ext_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppxl.sas7bdat")
df_microbio <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/mb.sas7bdat")
# df_medicalhist <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/mh.sas7bdat")
# df_medicalhist_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppmh.sas7bdat")
# df_resp_procedure <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/pr.sas7bdat")
# df_resp_procedure_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/supppr.sas7bdat")
# df_rel_CM_AE <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/relrec.sas7bdat")
# # df_do_not_intubate <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/sc.sas7bdat")
# # df_do_not_intubate_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppsc.sas7bdat")
# # df_unknown <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/se.sas7bdat")
# df_death <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/ss.sas7bdat")
# df_substance_use <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/su.sas7bdat")
df_substance_use_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppsu.sas7bdat")
# df_subj_visits <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/sv.sas7bdat")
# df_subj_visit_findings <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/xv.sas7bdat")
# # df_unknown <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/ta.sas7bdat")
# # df_unknown <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/te.sas7bdat")
# # df_screen_exclusions <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/ti.sas7bdat")
# # df_trial_info <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/ts.sas7bdat")
# # df_trial_info2 <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/tv.sas7bdat")
# df_vitalsigns <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/vs.sas7bdat")
# df_vitalsigns_suppO2 <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppvs.sas7bdat")
# df_chest_imaging <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/xp.sas7bdat")
# df_chest_imaging_supp <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/SDTM_KHAA_final_new/suppxp.sas7bdat")

# ADaM_KHAA_final_new
df_ae_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adae.sas7bdat")
df_comed_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adcm.sas7bdat")
df_disco_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adds.sas7bdat")
# df_prot_dev_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/addv.sas7bdat")
# df_dose_details_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adex.sas7bdat")
df_lab_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adlb.sas7bdat")
# df_lab_ext_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adlbcn.sas7bdat")
df_medicalhist_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/admh.sas7bdat")
df_niaid_score_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adniaid.sas7bdat")
df_ind_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adsl.sas7bdat")
# df_ind2_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adsl2.sas7bdat")
df_tte_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adtte.sas7bdat")
# df_tte2_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/adtte2.sas7bdat")
# df_vitalsigns_set <- read_sas("/Users/amstutzal/Library/CloudStorage/OneDrive-usb.ch/Dokumente - JAKi IPDMA data source management/General/COV-BARRIER/ADaM_KHAA_final_new/advs.sas7bdat")
```

# Define ITT population and mark COV-BARRIER and COV-BARRIER expl.
```{r echo=TRUE}
df <- df_ind_set %>% # keep only those randomized
  filter(RANDFL == "Y")
df <- df %>% # mark COV-BARRIER (main trial, all severity except MV/ECMO) and COV-BARRIER exploratory (only MV/ECMO)
  mutate(subtrial = case_when(BNIAID == "7" ~ "COV-BARRIER_MV",
                               TRUE ~ c("COV-BARRIER_main")))
addmargins(table(df$ARM, df$subtrial))
```

# Baseline Characteristics
```{r echo=TRUE, message=FALSE, warning=FALSE}
df <- df %>% # no missing in all these
  rename(id_pat = SUBJID,
         country = COUNTRY,
         randdate = RANDDT
         )
df <- df %>% # COV-BARRIER exploratory (only MV/ECMO) were recruited in ICU
  mutate(icu = case_when(subtrial == "COV-BARRIER_MV" ~ 1,
                               TRUE ~ 0))
df <- df %>%
  mutate(trt = case_when(ARM == "Baricitinib-4mg-QD" ~ 1,
                         TRUE ~ 0))
# add trial variables
df$trial <- c("COV-BARRIER")
df$JAKi <- c("Baricitinib")
df <- df %>% # no missing in sex
  mutate(sex = case_when(SEX == "F" ~ "female",
                         SEX == "M" ~ "male"))
# Ethnicity
df <- df %>% # no missing in ethnicity
  mutate(ethn = case_when(RACE == "UNKNOWN" & ETHNIC == "HISPANIC OR LATINO" ~ "HISPANIC OR LATINO",
                          TRUE ~ c(RACE)))
# AGE: add 90 to ages ">89" // age data also not available in df_demographics due to anonymization
df$age <- as.numeric(df$AGE)
df <- df %>%
  mutate(age = case_when(is.na(age) ~ 90,
                         TRUE ~ c(age)))
df %>% 
  drop_na(age) %>% 
  ggplot(aes(x = age)) +
  geom_density(fill = "blue", color = "black") +
  labs(title = "Density Plot of Age",
       x = "Age",
       y = "Density")

# Days with symptoms prior to randomization
df <- df %>% 
  mutate(sympdur = case_when(SYMHDUR == "-24" ~ "0",
                             SYMHDUR == "-22" ~ "0",
                             SYMHDUR == "-16" ~ "0",
                             SYMHDUR == "-15" ~ "0",
                             SYMHDUR == "-8" ~ "0",
                             TRUE ~ c(SYMHDUR)))
df$sympdur <- as.numeric(df$sympdur)
df %>% 
  drop_na(sympdur) %>% 
  ggplot(aes(x = sympdur)) +
  geom_density(fill = "blue", color = "black") +
  labs(title = "Density Plot of Symptom Duration",
       x = "Symptom Duration",
       y = "Density")

# Severity of COVID-19 with respect to respiratory support at randomisation, according to NIAID score
# transform all clinical scores
score_transform <- function(df, clinstatus_var, score_var) {
  df <- df %>%
    mutate({{ clinstatus_var }} :=
             case_when({{ score_var }} %in% c(1, 2, 3) ~ 1,
                       {{ score_var }} == 4 ~ 2,
                       {{ score_var }} == 5 ~ 3,
                       {{ score_var }} == 6 ~ 4,
                       {{ score_var }} == 7 ~ 5,
                       {{ score_var }} == 8 ~ 6)) %>%
    mutate({{ clinstatus_var }} := factor({{ clinstatus_var }}, levels = 1:6))
}
df <- score_transform(df, clinstatus_baseline, BNIAIDN) 
# addmargins(table(df$clinstatus_baseline, df$trt, useNA = "always")) # 7 missing
# addmargins(table(df$clinstatus_baseline, df$trt, df$subtrial, useNA = "always")) # 7 missing in COV-BARRIER main, no missing in COV-BARRIER 2 // # corresponds to publications

df <- df %>% 
  mutate(vbaseline = case_when(clinstatus_baseline == "2" | clinstatus_baseline == "3" ~ 0,
                                clinstatus_baseline == "4" | clinstatus_baseline == "5" ~ 1))

### Co-medication at baseline
# table(df$BLSTRFN, df$trt, df$subtrial, useNA = "always") # corresponds to publications
# table(df$BRMDSVFL, df$trt, df$subtrial, useNA = "always") # corresponds to publications

# check df_comed_set for prior/baseline co-medications for the following:
df$comed_toci <- 0 # excluded according to protocol
df$comed_acoa <- NA
df$comed_interferon <- 0 # excluded according to protocol

df <- df %>% 
  mutate(comed_dexa = case_when(BLSTRFN == 1 ~ 1,
                                BLSTRFN == 0 ~ 0))
df <- df %>% 
  mutate(comed_rdv = case_when(BRMDSVFL == "Y" ~ 1,
                                TRUE ~ 0))
df <- df %>% 
  mutate(comed_ab = case_when(PTHANTBI == "Y" ~ 1,
                                TRUE ~ 0))
df <- df %>% 
  mutate(comed_other = case_when(PTHOTH == "Y" ~ 1,
                                TRUE ~ 0))
# group them for the subgroup analysis, according to protocol
df <- df %>% 
  mutate(comed_cat = case_when(comed_dexa == 0 & (comed_toci == 0 | is.na(comed_toci)) ~ 1, # patients without Dexamethasone nor Tocilizumab
                               comed_dexa == 1 & (comed_toci == 0 | is.na(comed_toci)) ~ 2, # patients with Dexamethasone but no Tocilizumab
                               comed_dexa == 1 & comed_toci == 1 ~ 3, # patients with Dexamethasone and Tocilizumab
                               comed_dexa == 0 & comed_toci == 1 ~ 4)) # patients with Tocilizumab but no Dexamethasone (if exist)


### Comorbidity at baseline, including immunocompromised
df <- df %>% 
  mutate(comorb_dm = case_when(CMRDFL == "Y" ~ 1,
                              CMRDFL == "N" ~ 0))
df <- df %>%
  mutate(comorb_obese = case_when(CMROFL == "Y" ~ 1,
                                   CMROFL == "N" ~ 0))
df <- df %>%
  mutate(comorb_aht = case_when(CMRHFL == "Y" ~ 1,
                                   CMRHFL == "N" ~ 0))
df <- df %>%
  mutate(comorb_lung = case_when(CMRCFL == "Y" ~ 1,
                                  CMRCFL == "N" ~ 0))
df <- df %>%
  mutate(comorb_kidney = case_when(BRNLGR1 == "Impaired" ~ 1,
                                   TRUE ~ 0))
# take it from medicalhistory dataset
df_medicalhist_set <- df_medicalhist_set %>% 
  mutate(comorb_cancer = case_when((grepl("Cancer", ALLT) | grepl("cancer", ALLT) | grepl("neoplasm", ALLT) | grepl("Neoplasm", ALLT) | grepl("carcinoma", ALLT) | grepl("Carcinoma", ALLT)) ~ 1))
df_medicalhist_set <- df_medicalhist_set %>% 
  mutate(comorb_liver = case_when(ALLT == "Chronic liver disease" ~ 1))
df_medicalhist_set <- df_medicalhist_set %>% 
  mutate(comorb_cvd = case_when(ASOC == "Cardiac disorders" ~ 1))
df_medicalhist_set <- df_medicalhist_set %>% 
  mutate(immunosupp = case_when((grepl("immune deficiency", ALLT) | grepl("Chemo", ALLT) | grepl("Radio", ALLT)) ~ 1))
df_medicalhist_set <- df_medicalhist_set %>% 
  mutate(comorb_autoimm = case_when((grepl("rheuma", ALLT) | grepl("Rheuma", ALLT) | grepl("immune", ALLT) | grepl("immune", ASOC) | grepl("immune", ADECOD)) & is.na(immunosupp) ~ 1))
# remove duplicates  
df_comorb_cancer <- df_medicalhist_set %>% 
  filter(comorb_cancer == 1) %>%
  distinct(USUBJID,comorb_cancer)
df_comorb_liver <- df_medicalhist_set %>% 
  filter(comorb_liver == 1) %>%
  distinct(USUBJID,comorb_liver)
df_comorb_cvd <- df_medicalhist_set %>% 
  filter(comorb_cvd == 1) %>%
  distinct(USUBJID,comorb_cvd)
df_immunosupp <- df_medicalhist_set %>% 
  filter(immunosupp == 1) %>%
  distinct(USUBJID,immunosupp)
df_comorb_autoimm <- df_medicalhist_set %>% 
  filter(comorb_autoimm == 1) %>%
  distinct(USUBJID,comorb_autoimm)
# merge
df <- left_join(df, df_comorb_cancer[, c("comorb_cancer", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
df <- left_join(df, df_comorb_liver[, c("comorb_liver", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
df <- left_join(df, df_comorb_cvd[, c("comorb_cvd", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
df <- left_join(df, df_immunosupp[, c("immunosupp", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
df <- left_join(df, df_comorb_autoimm[, c("comorb_autoimm", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df

# take smoking from substance use set
df_substance_use_supp <- df_substance_use_supp %>% 
  mutate(comorb_smoker = case_when(QVAL == "CURRENT" ~ 1))
df_comorb_smoker <- df_substance_use_supp %>% 
  filter(comorb_smoker == 1) %>%
  distinct(USUBJID,comorb_smoker)
df <- left_join(df, df_comorb_smoker[, c("comorb_smoker", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df

# the remaining missing have only NA in 1 comorb category => no evidence for comorbidity -> recode as 0
# table(df$PTHIMMSP)
df <- df %>% 
  mutate(comorb_cancer = case_when(is.na(comorb_cancer) ~ 0,
                                TRUE ~ c(comorb_cancer)),
         comorb_liver = case_when(is.na(comorb_liver) ~ 0,
                                TRUE ~ c(comorb_liver)),
         comorb_cvd = case_when(is.na(comorb_cvd) ~ 0,
                                TRUE ~ c(comorb_cvd)),
         immunosupp = case_when(is.na(immunosupp) ~ 0,
                                TRUE ~ c(immunosupp)),
         comorb_autoimm = case_when(is.na(comorb_autoimm) ~ 0,
                                TRUE ~ c(comorb_autoimm)),
         comorb_smoker = case_when(is.na(comorb_smoker) ~ 0,
                                TRUE ~ c(comorb_smoker)))
df <- df %>% 
  mutate(any_comorb = case_when(comorb_lung == 1 | comorb_liver == 1 | comorb_cvd == 1 |
                                  comorb_aht == 1 | comorb_dm == 1 | comorb_obese == 1 | comorb_smoker == 1
                                | immunosupp == 1 | comorb_cancer == 1 | comorb_autoimm == 1 | comorb_kidney == 1 
                                  ~ 1,
                                comorb_lung == 0 & comorb_liver == 0 & comorb_cvd == 0 &
                                  comorb_aht == 0 & comorb_dm == 0 & comorb_obese == 0 & comorb_smoker == 0
                                & immunosupp == 0 & comorb_cancer == 0 & comorb_autoimm == 0 & comorb_kidney == 0
                                ~ 0))
# addmargins(table(df$any_comorb, df$trt, useNA = "always"))

## group them for the subgroup analysis, according to protocol // count all pre-defined comorbidities per patient first
comorb <- df %>% 
  select("id_pat", "comorb_lung", "comorb_liver", "comorb_cvd", "comorb_aht", "comorb_dm", "comorb_obese", "comorb_smoker", "immunosupp", "comorb_kidney", "comorb_autoimm", "comorb_cancer")
comorb$comorb_count <- NA
for (i in 1:dim(comorb)[[1]]) {
  comorb$comorb_count[i] <- ifelse(
    sum(comorb[i, ] %in% c(1)) > 0,
    sum(comorb[i, ] %in% c(1)),
    NA
  )
}
comorb <- comorb %>%
  mutate(comorb_count = case_when(comorb_lung == 0 & comorb_liver == 0 & comorb_cvd == 0 &
                                  comorb_aht == 0 & comorb_dm == 0 & comorb_obese == 0 & comorb_smoker == 0
                                & immunosupp == 0 & comorb_cancer == 0 & comorb_autoimm == 0 & comorb_kidney == 0 ~ 0,
                                TRUE ~ comorb_count))
df <- left_join(df, comorb[, c("comorb_count", "id_pat")], by = join_by(id_pat == id_pat)) ## merge imputed variable back
df <- df %>%
  mutate(comorb_cat = case_when(immunosupp == 1 ~ 4, # immunocompromised
                                comorb_count == 0 ~ 1, # no comorbidity
                                comorb_count == 1 & (immunosupp == 0 | is.na(immunosupp)) ~ 2, # one comorbidity
                                comorb_count >1 & (immunosupp == 0 | is.na(immunosupp)) ~ 3)) # multiple comorbidities
# addmargins(table(df$comorb_cat, df$trt, useNA = "always"))
df <- df %>%
  mutate(comorb_any = case_when(comorb_count == 0 ~ 0, # no comorbidity
                                comorb_count >0 ~ 1)) # any comorbidity


## CRP
df_crp <- df_lab_set %>% 
  filter(LBTESTCD == "CRP") %>% 
  filter(VISIT == "Screening") %>% 
  filter(AVISITN == 1)
df_crp <- df_crp %>% 
  distinct(USUBJID, .keep_all = TRUE)
df_crp <- df_crp %>% 
  rename(crp = LBSTRESN)
df <- left_join(df, df_crp[, c("crp", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
df %>% 
  drop_na(crp) %>% 
  ggplot(aes(x = crp)) +
  geom_density(fill = "blue", color = "black") +
  labs(title = "Density Plot of Symptom Duration",
       x = "CRP",
       y = "Density")

# Viremia dataset 
df_viremia <- df_microbio %>% 
  filter(MBTESTCD != "MBALL") %>% 
  filter(MBTSTDTL == "DETECTION") %>% 
  filter(MBBLFL == "Y")
df_viremia <- df_viremia %>% 
  distinct(USUBJID, .keep_all = TRUE)
df_viremia <- df_viremia %>% # viral load value <LOQ and/or undectectable
  mutate(vl_baseline = case_when(MBORRES == "POSITIVE" ~ 0,
                                 TRUE ~ 1))
df <- left_join(df, df_viremia[, c("vl_baseline", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df

# Vaccination // not available
# Variant // not available
# Serology // not available

```

# Endpoints
```{r echo=TRUE}
# (i) Primary outcome: Mortality at day 28
df_ttd <- df_tte_set %>% # death set
  filter(PARAM == "Time to Death by Day 28") %>% 
  filter(RANDFL == "Y") # only randomised population
# discontinuation set
df_disco_any <- df_disco_set %>% 
  filter(DSDECOD != "COMPLETED" & DSDECOD != "DEATH") %>% # any other reason than these
  filter(RANDFL == "Y") %>% # only randomized population
  filter(DSSCAT == "STUDY DISPOSITION"| DSSCAT == "TREATMENT DISPOSITION") %>% # full study dispo, not only treatment or drug dispo
  distinct(USUBJID, ADT, EPOCH, DSDECOD, DSTERM)
df_disco_any <- df_disco_any %>%
  mutate(dupl = ifelse(duplicated(select(., USUBJID, ADT)), 1, 0))
df_disco_any <- df_disco_any %>%
  filter(dupl == 0)
df_disco_any <- df_disco_any %>%
  mutate(dupl2 = ifelse(duplicated(select(., USUBJID)), 1, 0))
df_disco_any <- df_disco_any %>%
  filter(dupl2 == 0)
df_ttd <- left_join(df_ttd, df_disco_any[, c("ADT", "EPOCH", "DSDECOD", "DSTERM", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
# mark those that were censored before day 28 (i.e. stop of follow up, not because of discharge or death, but because of AE/withdrawal/LTFU/etc.)
df_ttd <- df_ttd %>% 
  mutate(disco_28 = case_when(AVAL <28 & CNSR == 1 ~ 1,
                            TRUE ~ 0))
df_ttd <- df_ttd %>% # identify deaths
  mutate(mort_28 = case_when(EVNTDESC == "Death on or before Day 28" ~ 1,
                             disco_28 == 0 ~ 0
                             ))
df <- left_join(df, df_ttd[, c("mort_28", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
addmargins(table(df$mort_28, df$trt, df$subtrial, useNA = "always")) # corresponds to publications: "*159 deaths were reported by day 28; an additional three deaths occurred after the treatment period disposition but within 28 days."

# First, keep mort_28 as complete case

# Second, use multiple imputation (see below)

# Third, apply a deterministic imputation (see notes): we use the same rules as ACTT2 => transfer that died are already accounted for, for the remaining -> assign "alive"
df <- df %>%
  mutate(mort_28_dimp = case_when(is.na(mort_28) ~ 0,
                             TRUE ~ c(mort_28)))


# (ii) Mortality at day 60
df_ttd <- df_tte_set %>% 
  filter(PARAM == "Time to Death by Day 60") %>% 
  filter(RANDFL == "Y") # only randomised population
df_ttd <- left_join(df_ttd, df_disco_any[, c("ADT", "EPOCH", "DSDECOD", "DSTERM", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge all disco
df_ttd <- df_ttd %>% # mark those that were censored before day 60 (i.e. stop of follow up, not because of discharge or death, but because of AE/withdrawal/LTFU/etc.)
  mutate(disco_60 = case_when(AVAL <60 & CNSR == 1 & !is.na(DSTERM) ~ 1,
                            TRUE ~ 0))
df_ttd <- df_ttd %>% # identify deaths using the censoring variable
  mutate(mort_60 = case_when(CNSR == 0 ~ 1,
                             disco_60 == 0 ~ 0))
df <- left_join(df, df_ttd[, c("mort_60", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
addmargins(table(df$mort_60, df$trt, df$subtrial, useNA = "always"))


# (iii) Time to death within max. follow-up time (systematically until 60 days!)
df_ttd <- df_tte_set %>% 
  filter(PARAM == "Time to Death") %>% 
  filter(RANDFL == "Y")
df_ttd <- df_ttd %>% # use censoring variable to identify deaths within 28 days, don't bother about the others
  mutate(death_reached = case_when(CNSR == 0 ~ 1,
                             CNSR == 1 ~ 0))
df_ttd$death_time <- df_ttd$AVAL
df <- left_join(df, df_ttd[, c("death_reached", "death_time", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
# table(df$death_time, df$death_reached, useNA = "always") 
# Cap at 60 days, since this was max. systematic follow-up, no deaths recorded afterwards anymore
df <- df %>% 
  mutate(death_time = case_when(death_time >60 ~ 60,
                                TRUE ~ c(death_time)))

# (iv) Alternative definition/analysis: New mechanical ventilation OR death within 28 days
# table(df_tte_set$PARAM)
df_mvd <- df_tte_set %>% 
  filter(PARAM == "Time to progression to invasive ventilation or death  (OS >= 7)") %>% # include the deaths, in order not to miss any event (subtract them in the end)
  filter(RANDFL == "Y") # only randomised population
df_mvd$tt_mv <- df_mvd$AVAL # time to MV (incl. censoring for those dead or last available visit) -> incl. longer than 28d!
df_mvd <- left_join(df_mvd, df_disco_any[, c("ADT", "EPOCH", "DSDECOD", "DSTERM", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge all disco
df_mvd <- df_mvd %>% # mark those that were discontinued before day 28 (i.e. stop of follow up, not because of discharge or death, but because of AE/withdrawal/LTFU/etc.)
  mutate(disco_28_mvd = case_when(AVAL <28 & CNSR == 1 & !is.na(DSTERM) ~ 1,
                            TRUE ~ 0))
df_mvd <- df_mvd %>% # identify deaths using the censoring variable
  mutate(new_mvd_28 = case_when(CNSR == 0 & tt_mv < 29 ~ 1,
                             disco_28_mvd == 0 ~ 0))
df <- left_join(df, df_mvd[, c("new_mvd_28", "disco_28_mvd", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
# table(df$new_mvd_28, df$mort_28, useNA = "always")
# table(df$clinstatus_baseline, df$new_mvd_28, useNA = "always")
# table(df$new_mvd_28, useNA = "always")
# table(df$mort_28, useNA = "always")

# (iv) New mechanical ventilation among survivors within 28 days
# table(df_tte_set$PARAM)
df_mv <- df_tte_set %>% 
  filter(PARAM == "Time to invasive ventilation (OS =7)") %>%
  filter(RANDFL == "Y") # only randomised population
df_mv$tt_mv <- df_mv$AVAL # time to MV (incl. censoring for those dead or last available visit) -> incl. longer than 28d!
df_mv <- left_join(df_mv, df_disco_any[, c("ADT", "EPOCH", "DSDECOD", "DSTERM", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge all disco
df_mv <- df_mv %>% # mark those that were discontinued before day 28 (i.e. stop of follow up, not because of discharge or death, but because of AE/withdrawal/LTFU/etc.)
  mutate(disco_28_mv = case_when(AVAL <28 & CNSR == 1 & !is.na(DSTERM) ~ 1,
                            TRUE ~ 0))
df_mv <- df_mv %>% # identify deaths using the censoring variable
  mutate(new_mv_28 = case_when(CNSR == 0 & tt_mv < 29 ~ 1,
                             disco_28_mv == 0 ~ 0))
df <- left_join(df, df_mv[, c("new_mv_28", "disco_28_mv", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
# table(df$new_mv_28, df$mort_28, useNA = "always")
# table(df$clinstatus_baseline, df$new_mv_28, useNA = "always")
# table(df$new_mv_28, useNA = "always")
# table(df$mort_28, useNA = "always")
# classify those dead within 28d and those that were MV at baseline as NA ("among survivors")
df <- df %>% 
  mutate(new_mv_28 = case_when(mort_28 == 1 | clinstatus_baseline == 5 ~ NA,
                               TRUE ~ c(new_mv_28)))
# table(df$new_mv_28, df$mort_28, useNA = "always")
# table(df$new_mv_28, df$clinstatus_baseline, useNA = "always")
# # see missing data rule: the 7 with no clinstatus at all, not even baseline clinstatus -> assume clinstatus == 5
# df <- df %>% 
#   mutate(new_mv_28 = case_when(is.na(clinstatus_baseline) ~ 1,
#                                TRUE ~ c(new_mv_28)))


# (vi) Time to discharge or reaching discharge criteria up to day 28
df_ttdis <- df_tte_set %>% 
  filter(PARAM == "Time to recovery by Day 28 (OS <=3)") %>% 
  filter(RANDFL == "Y")
df_ttdis$discharge_time <- df_ttdis$AVAL # time to discharge -> longer than 28d!
# table(df_ttdis$EVNTDESC, df_ttdis$discharge_time) # CAVE: Those that died have all assigned 28 days!
df_ttdis <- df_ttdis %>% # use censoring variable to identify MV 
  mutate(discharge_reached = case_when(discharge_time < 29 & CNSR == 0 ~ 1,
                                       TRUE ~ 0))
# table(df_ttdis$discharge_reached, df_ttdis$discharge_time, useNA = "always")
df <- left_join(df, df_ttdis[, c("discharge_reached", "discharge_time", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
df <- df %>% # add time to death for those that died
  mutate(discharge_time = case_when(mort_28 == 1 ~ death_time,
                                    TRUE ~ discharge_time))
df <- df %>% # Cap at 28 days
  mutate(discharge_time = case_when(discharge_time >28 ~ 28,
                                TRUE ~ c(discharge_time)))
# table(df$discharge_reached, df$discharge_time, useNA = "always")
df <- df %>% # add 28d for those that died // Patients who died prior to day 28 are assumed not having reached discharge, i.e. counted as 28 days
  mutate(discharge_time_sens = case_when(mort_28 == 1 ~ 28,
                                    TRUE ~ discharge_time))
# table(df$discharge_reached, df$discharge_time_sens, useNA = "always") -> correct. Corresponds to # table(df_ttdis$discharge_reached, df_ttdis$discharge_time, useNA = "always")


# (v) Clinical status at day 28
## first, curate clinical score long format dataset
df_cs_long <- df_niaid_score_set %>%
  filter(PARAM == "NIAID OS Scale") %>% 
  filter(ABLFL != "Y") %>% # remove baseline clinicalstatus
  filter(VISIT != "") # remove missed visits that were LOVCF
df_cs_long <- score_transform(df_cs_long, clinstatus, AVAL) # transform the NIAID score to our score
# second, reformat into wide format
df_cs_wide <- df_cs_long %>% ## the ones with missing baseline clinstatus are missing
  pivot_wider(id_cols = c("USUBJID"),
              names_from = "VISIT",
              values_from = "clinstatus")
# table(df_cs_wide$`Day 28`)
df <- left_join(df, df_cs_wide, by = join_by(USUBJID == USUBJID)) # Merge imputed variable back
df <- df %>% 
  rename(clinstatus_1 = Screening,
         clinstatus_2 = `Day 2`,
         clinstatus_3 = `Day 3`,
         clinstatus_4 = `Day 4`,
         clinstatus_5 = `Day 5`,
         clinstatus_6 = `Day 6`,
         clinstatus_7 = `Day 7`,
         clinstatus_8 = `Day 8`,
         clinstatus_9 = `Day 9`,
         clinstatus_10 = `Day 10`,
         clinstatus_11 = `Day 11`,
         clinstatus_12 = `Day 12`,
         clinstatus_13 = `Day 13`,
         clinstatus_14 = `Day 14`,
         clinstatus_15 = `Day 15`,
         clinstatus_16 = `Day 16`,
         clinstatus_17 = `Day 17`,
         clinstatus_18 = `Day 18`,
         clinstatus_19 = `Day 19`,
         clinstatus_20 = `Day 20`,
         clinstatus_21 = `Day 21`,
         clinstatus_22 = `Day 22`,
         clinstatus_23 = `Day 23`,
         clinstatus_24 = `Day 24`,
         clinstatus_25 = `Day 25`,
         clinstatus_26 = `Day 26`,
         clinstatus_27 = `Day 27`,
         clinstatus_28 = `Day 28`,
         clinstatus_29 = `Follow-up`,
         clinstatus_30 = `Final Status`,
         clinstatus_60 = `Follow-Up Day 60`)

## Imputation according to protocol: If there was daily data for the ordinal score available but with missing data for single days, then we carried last observed value forward unless for day 28, whereby we first considered data from the window (+/-3 days) but there was nothing in that window => LVCF
# table(df$clinstatus_baseline, useNA = "always")
df <- df %>% # see imputation rules
  mutate(clinstatus_baseline_imp = case_when(is.na(clinstatus_baseline) ~ "5",
                                         TRUE ~ clinstatus_baseline))
dfcs <- df %>% 
    select(USUBJID, clinstatus_baseline_imp, clinstatus_1, clinstatus_2, clinstatus_3, clinstatus_4, clinstatus_5, clinstatus_6, clinstatus_7, clinstatus_8, clinstatus_9, clinstatus_10, clinstatus_11, clinstatus_12, clinstatus_13, clinstatus_14, clinstatus_15, clinstatus_16, clinstatus_17, clinstatus_18, clinstatus_19, clinstatus_20, clinstatus_21, clinstatus_22, clinstatus_23, clinstatus_24, clinstatus_25, clinstatus_26, clinstatus_27, clinstatus_28)
impute_last_forw = function(df){
  first = which(names(df)%in%c("clinstatus_baseline_imp"))
  last = which(names(df)%in%c("clinstatus_28"))
  for (i in 1:dim(df)[[1]]){
    for (j in first[1]:last[1]){
      p = df[i, j]
      df[i,j] <- 
        ifelse(!is.na(df[i, j]), p, df[i, j-1])
    }
  }
  df
}
dfcs <- impute_last_forw(dfcs)
dfcs <- dfcs %>% # To control, don't overwrite
  rename(clinstatus_28_imp = clinstatus_28)
df <- left_join(df, dfcs[, c("clinstatus_28_imp", "USUBJID")], by = join_by(USUBJID == USUBJID)) # Merge imputed variable back
# table(df$clinstatus_28, useNA = "always")
# table(df$clinstatus_28_imp, useNA = "always") # imputed

# df %>% # these ones were discharged, but then readmitted (1 even died, but after day 28)
#   filter(clinstatus_28 != 1 & discharge_reached == 1) %>%
#   select(discharge_reached, discharge_time, clinstatus_28, clinstatus_baseline, mort_28, mort_60, new_mvd_28, new_mv_28, everything()) %>%
#   View()

# (vi) Sens-analysis: Alternative definition/analysis of outcome: time to sustained discharge within 28 days. There are 8 re-admissions documented in COV-BARRIER
df <- df %>% 
  mutate(discharge_reached_sus = case_when(discharge_reached == 1 & clinstatus_28 != 1 ~ 0,
                                           TRUE ~ c(discharge_reached)))
df <- df %>% 
  mutate(discharge_time_sus = case_when(discharge_reached == 1 & clinstatus_28 != 1 ~ 28,
                                           TRUE ~ c(discharge_time)))
# table(df$discharge_reached_sus, df$discharge_reached)

# (vii) Viral clearance up to day 5, day 10, and day 15 (Viral load value <LOQ and/or undectectable)
df_viremia <- df_microbio %>% 
  filter(MBTESTCD != "MBALL") %>% 
  filter(MBTSTDTL == "DETECTION")
# table(df_viremia$VISITNUM, useNA = "always") # the NAs are not relevant: They are either from before randomization or after day 15
df_viremia <- df_viremia %>% 
  filter(VISITNUM %in% c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15))
df_viremia <- df_viremia %>% # viral load value <LOQ and/or undectectable
  mutate(vl = case_when(MBORRES == "POSITIVE" ~ 0,
                                 MBORRES == "NEGATIVE" ~ 1))
# Filtering and extracting the last measurement for each participant
df_vir_clear_5 <- df_viremia %>%
  filter(VISITNUM <= 5) %>%
  group_by(SUBJID) %>%
  slice_max(VISITNUM)
df_vir_clear_5$vir_clear_5 <- df_vir_clear_5$vl
# Check for duplicates in SUBJID and VL
df_vir_clear_5 <- df_vir_clear_5 %>%
  mutate(participant_duplicate = duplicated(SUBJID) | duplicated(SUBJID, fromLast = TRUE))
df_vir_clear_5 <- df_vir_clear_5 %>% # remove exact duplicates
  distinct(SUBJID, vir_clear_5, .keep_all = TRUE)
specific_duplicates <- any(duplicated(df_vir_clear_5[, c("SUBJID")]))

df_vir_clear_10 <- df_viremia %>%
  filter(VISITNUM <= 10) %>%
  group_by(SUBJID) %>%
  slice_max(VISITNUM)
df_vir_clear_10$vir_clear_10 <- df_vir_clear_10$vl
# Check for duplicates in SUBJID and VL
df_vir_clear_10 <- df_vir_clear_10 %>%
  mutate(participant_duplicate = duplicated(SUBJID) | duplicated(SUBJID, fromLast = TRUE))
df_vir_clear_10 <- df_vir_clear_10 %>% # remove exact duplicates
  distinct(SUBJID, vir_clear_10, .keep_all = TRUE)
specific_duplicates <- any(duplicated(df_vir_clear_10[, c("SUBJID")]))

df_vir_clear_15 <- df_viremia %>%
  filter(VISITNUM <= 15) %>%
  group_by(SUBJID) %>%
  slice_max(VISITNUM)
df_vir_clear_15$vir_clear_15 <- df_vir_clear_15$vl
# Check for duplicates in SUBJID and VL
df_vir_clear_15 <- df_vir_clear_15 %>%
  mutate(participant_duplicate = duplicated(SUBJID) | duplicated(SUBJID, fromLast = TRUE))
df_vir_clear_15 <- df_vir_clear_15 %>% # remove exact duplicates
  distinct(SUBJID, vir_clear_15, .keep_all = TRUE)
specific_duplicates <- any(duplicated(df_vir_clear_15[, c("SUBJID")]))

df <- left_join(df, df_vir_clear_5[, c("vir_clear_5", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
df <- left_join(df, df_vir_clear_10[, c("vir_clear_10", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df
df <- left_join(df, df_vir_clear_15[, c("vir_clear_15", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge to main df


# (viii) Quality of life at day 28: Not available in COV-BARRIER


# (ix) Participants with an adverse event grade 3 or 4, or a serious adverse event, excluding death, by day 28
# unique(df_ae_set$ASTDY)
df_ae34 <- df_ae_set %>% 
  filter(AESEV == "SEVERE" | AESEV == "MODERATE" | AESER == "Y") %>% 
  filter(ASTDY <29)
# Keep just 1 id_pat (-> ANY adverse event grade 3 (severe), 4 (serious)) 
df_ae34_unique <- df_ae34 %>% distinct(USUBJID, .keep_all = TRUE)
# Assign the outcome
df_ae34_unique$ae_28 <- 1
# table(df_ae34_unique$ae_28)
# merge
df <- left_join(df, df_ae34_unique[, c("ae_28", "USUBJID")], by = join_by(USUBJID == USUBJID)) ## merge variable to main df
# the remaining missing have no AE grade 34 -> recode as 0 and exclude deaths
df <- df %>% 
  mutate(ae_28 = case_when(is.na(ae_28) & mort_28 == 0 ~ 0,
                           is.na(ae_28) & mort_28 == 1 ~ NA,
                           TRUE ~ ae_28))
df <- df %>% 
  mutate(ae_28 = case_when(mort_28 == 1 ~ NA,
                           TRUE ~ ae_28))
# table(df$ae_28, df$mort_28, useNA = "always")
# addmargins(table(df$ae_28, df$trt, useNA = "always"))
# (ix) Sens-analysis: Alternative definition/analysis of outcome: incidence rate ratio (Poisson regression) -> AE per person by d28
ae_npp <- df_ae34 %>% 
  group_by(USUBJID)%>%  
  summarise(ae_28_sev = n())
df <- left_join(df, ae_npp[, c("ae_28_sev", "USUBJID")], by = join_by(USUBJID == USUBJID)) # merge variable to main df
# the remaining missing have no AE grade 34 -> recode as 0 and exclude deaths
df <- df %>% 
  mutate(ae_28_sev = case_when(is.na(ae_28_sev) & mort_28 == 0 ~ 0,
                           is.na(ae_28_sev) & mort_28 == 1 ~ NA,
                           TRUE ~ ae_28_sev))
df <- df %>% 
  mutate(ae_28_sev = case_when(mort_28 == 1 ~ NA,
                           TRUE ~ ae_28_sev))
# table(df$ae_28_sev, df$mort_28, useNA = "always")
# addmargins(table(df$ae_28_sev, df$trt, useNA = "always"))

# (ix) Sens-analysis: Alternative definition/analysis of outcome: time to first (of these) adverse event, within 28 days, considering death as a competing risk (=> censor and set to 28 days)
# re-discuss

# (x) Adverse events of special interest within 28 days: a) thromboembolic events (venous thromboembolism, pulmonary embolism, arterial thrombosis), b) secondary infections (bacterial pneumonia including ventilator-associated pneumonia, meningitis and encephalitis, endocarditis and bacteremia, invasive fungal infection including pulmonary aspergillosis), c) Reactivation of chronic infection including tuberculosis, herpes simplex, cytomegalovirus, herpes zoster and hepatitis B, d) serious cardiovascular and cardiac events (including stroke and myocardial infarction), e) events related to signs of bone marrow suppression (anemia, lymphocytopenia, thrombocytopenia, pancytopenia), f) malignancy, g) gastrointestinal perforation (incl. gastrointestinal bleeding/diverticulitis), h) liver dysfunction/hepatotoxicity (grade 3 and 4)
df_ae_tot <- df_ae_set %>% 
  filter(ASTDY <29)
df_ae_tot <- left_join(df_ae_tot, df[, c("trt", "USUBJID")], by = join_by(USUBJID == USUBJID)) 
df_ae_tot <- df_ae_tot %>% 
  rename(ae = AEDECOD,
         ae_class = AESOC,
         ae_desc = AEHLT)

df_thrombo <- df_ae_tot %>% # a) thromboembolic events (venous thromboembolism, pulmonary embolism, arterial thrombosis)
  filter(grepl("thrombos|embo|occl", ae, ignore.case = TRUE)) %>% 
  mutate(aesi = "thrombo")
df_sec_inf <- df_ae_tot %>% # b) secondary infections (bacterial pneumonia including ventilator-associated pneumonia, meningitis and encephalitis, endocarditis and bacteremia, invasive fungal infection including pulmonary aspergillosis), but not COVID-19 pneumonia!
  filter(ae_class %in% c("Infections and infestations") & !grepl("shock|herpes|COVID-19|sinusitis", ae, ignore.case = TRUE)) %>% 
  mutate(aesi = "sec_inf")
df_reactivate <- df_ae_tot %>% # c) Reactivation of chronic infection including tuberculosis, herpes simplex, cytomegalovirus, herpes zoster and hepatitis B
  filter(grepl("hepatitis|zoster|herpes|cytome|tuber|tb", ae, ignore.case = TRUE) | ae_desc %in% c("Herpes viral infections")) %>%
  mutate(aesi = "reactivate")
df_cardiac <- df_ae_tot %>% # d) serious cardiovascular and cardiac events (including stroke and myocardial infarction) (excl. hypertension)
  filter(ae_class %in% c("Cardiac disorders") | grepl("stroke|cerebrovascular|infarction|ischaemia|ischemia", ae, ignore.case = TRUE)) %>% 
  mutate(aesi = "cardiac")
df_penia <- df_ae_tot %>% # e) events related to signs of bone marrow suppression (anemia, lymphocytopenia, thrombocytopenia, pancytopenia)
  filter(grepl("penia|anemia|anaemia", ae, ignore.case = TRUE) | grepl("penia|anemia|anaemia", ae_desc, ignore.case = TRUE)) %>% 
  mutate(aesi = "penia")
df_malig <- df_ae_tot %>% # f) malignancy
  filter(ae_class %in% c("Neoplasms benign, malignant and unspecified (incl cysts and polyps)") 
         # | grepl("cancer|neopl|malig", ae, ignore.case = TRUE) | grepl("cancer|neopl|malig", ae_desc, ignore.case = TRUE)
         ) %>%
  mutate(aesi = "malig")
df_git_bl <- df_ae_tot %>% # g) gastrointestinal perforation (incl. gastrointestinal bleeding/diverticulitis)
  filter(ae_class %in% c("Hepatobiliary disorders","Gastrointestinal disorders") & (grepl("hemor|haemor|bleed", ae, ignore.case = TRUE) | grepl("hemor|haemor|bleed", ae_desc, ignore.case = TRUE))) %>% 
  mutate(aesi = "git_bl")
df_hepatox <- df_ae_tot %>% # h) liver dysfunction/hepatotoxicity (grade 3 and 4)
  filter(ae_class %in% c("Hepatobiliary disorders") & grepl("hepatox|liver injury|damage|failure|hypertrans|abnormal|hyperbili", ae, ignore.case = TRUE)) %>%
  mutate(aesi = "hepatox")
df_mods <- df_ae_tot %>% # i) Multiple organ dysfunction syndrome and septic shock
  filter(grepl("Multiple organ dysfunction syndrome|mods|shock", ae, ignore.case = TRUE)) %>% 
  mutate(aesi = "mods")

df_aesi <- rbind(df_mods, df_hepatox, df_git_bl, df_malig, df_penia, df_cardiac, df_reactivate, df_sec_inf, df_thrombo)
df_aesi <- df_aesi %>%
  rename(id_pat = USUBJID) %>% 
  select(id_pat, trt, aesi, ae, ae_desc, ae_class)
table(df_aesi$trt, df_aesi$aesi)
# double-check if there are any duplicate AEs within the same person and if it is the same event or distinct ones
df_aesi <- df_aesi %>% 
  group_by(id_pat) %>% 
  mutate(duplicate_id = duplicated(ae) & !is.na(ae)) %>% 
  ungroup()
df_aesi <- df_aesi %>% 
  filter(duplicate_id == F)
# Save
saveRDS(df_aesi, file = "df_aesi_cov-barrier.RData")


# (xi) Adverse events, any grade and serious adverse event, excluding death, within 28 days, grouped by organ classes
df_ae <- df_ae_tot %>%
  rename(id_pat = USUBJID) %>% 
  select(id_pat, trt, ae, ae_desc, ae_class)
# double-check if there are any duplicate AEs within the same person and if it is the same event or distinct ones
df_ae <- df_ae %>% 
  group_by(id_pat) %>% 
  mutate(duplicate_id = duplicated(ae) & !is.na(ae)) %>% 
  ungroup()
df_ae <- df_ae %>% 
  filter(duplicate_id == F)
# Save
saveRDS(df_ae, file = "df_ae_cov-barrier.RData")
```
Discussion points OUTCOME data

# Define final datasets
```{r echo=TRUE}
# keep the overall set
df_all <- df
# reduce the df set to our standardized set across all trials
df <- df %>% 
  select(id_pat, trt, sex, age, trial, JAKi, 
         ethn, 
         country, icu, sympdur, 
         # vacc, 
         clinstatus_baseline, vbaseline,
         comed_dexa, comed_rdv, comed_toci, comed_ab, comed_acoa, comed_interferon, comed_other,
         comed_cat,
         comorb_lung, comorb_liver, comorb_cvd, comorb_aht, comorb_dm, comorb_obese, comorb_smoker, immunosupp,
         comorb_autoimm, comorb_cancer, comorb_kidney,
         any_comorb, comorb_cat, comorb_any, comorb_count,
         crp, 
         # sero, variant,
         vl_baseline, 
         mort_28, mort_28_dimp,
         mort_60, death_reached, death_time,
         new_mv_28, new_mvd_28,
         clinstatus_28_imp,
         discharge_reached, discharge_time, discharge_time_sens, discharge_reached_sus, discharge_time_sus,
         ae_28, ae_28_sev,
         vir_clear_5, vir_clear_10, vir_clear_15
         )

# export for one-stage model, i.e., add missing variables 
df_os <- df
df_os$vacc <- NA
df_os$sero <- NA
df_os$variant <- NA
# Save
saveRDS(df_os, file = "df_os_cov-barrier.RData")
```

# Missing data plot: One-stage dataset
```{r echo=TRUE}
# Bar plot, missing data, each data point, standardized one-stage dataset
original_order <- colnames(df_os)
missing_plot <- df_os %>%
  summarise_all(~ mean(is.na(.))) %>%
  gather() %>%
  mutate(key = factor(key, levels = original_order)) %>%
  ggplot(aes(x = key, y = value)) +
  geom_bar(stat = "identity") +
  labs(x = "Columns", y = "Proportion of Missing Values", title = "Missing Data - standardized one-stage dataset") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ylim(0, 1)
print(missing_plot)
```
Discussion points
1. Missing variables:
* Baseline:
  - comed_acoa: double-check
  - sero
  - variant
* Outcomes:
  - qol_28
2. Missing data in:
  - clinstatus_baseline
  - comed_dexa & comed_cat
  - sympdur
  - crp
  - vl_baseline
  - new_mv_28: part of denominator
  - new_mvd_28
  - viral load outcomes

# Missing data: Explore
```{r message=FALSE, warning=FALSE}
# keep the core df
# names(df_all)
df_core <- df_all %>%
    select(id_pat, trt, sex, age, trial, JAKi, ethn, 
           # vacc, 
         country, icu, sympdur, clinstatus_baseline, vbaseline,
         comed_dexa, comed_rdv, comed_toci, comed_ab, comed_acoa, comed_interferon, comed_other,
         comed_cat,
         comorb_lung, comorb_liver, comorb_cvd, comorb_aht, comorb_dm, comorb_obese, comorb_smoker, immunosupp,
         comorb_autoimm, comorb_cancer, comorb_kidney,
         any_comorb, comorb_cat, comorb_any, comorb_count,
         crp, vl_baseline, 
         # sero, variant,
         clinstatus_1, clinstatus_2, clinstatus_3, clinstatus_4, clinstatus_5, clinstatus_6, clinstatus_7, clinstatus_8, clinstatus_9, clinstatus_10, clinstatus_11, clinstatus_12, clinstatus_13, clinstatus_14, clinstatus_15, clinstatus_16, clinstatus_17, clinstatus_18, clinstatus_19, clinstatus_20, clinstatus_21, clinstatus_22, clinstatus_23, clinstatus_24, clinstatus_25, clinstatus_26, clinstatus_27, clinstatus_28, clinstatus_60, clinstatus_29, clinstatus_30, 
         clinstatus_28_imp,
         mort_28, mort_28_dimp, mort_60, death_reached, death_time,
         new_mv_28, new_mvd_28,
         discharge_reached, discharge_time, discharge_time_sens, discharge_reached_sus, discharge_time_sus,
         vir_clear_5, vir_clear_10, vir_clear_15,
         ae_28, ae_28_sev
         )

# Convert character variables to factors
char_vars <- c("id_pat", "sex", "trial", "JAKi", "country", "icu", "ethn", "clinstatus_baseline", "vbaseline", 
               "comed_dexa", "comed_rdv", "comed_toci", "comed_ab", "comed_acoa", "comed_interferon", "comed_other", "comed_cat",
               "comorb_lung", "comorb_liver", "comorb_cvd", "comorb_aht", "comorb_dm", "comorb_obese", "comorb_smoker", "immunosupp", "any_comorb", "comorb_cat", "comorb_any", "comorb_autoimm","comorb_cancer", "comorb_kidney", "vl_baseline", "clinstatus_28_imp", "mort_28", "mort_28_dimp", "mort_60", "death_reached", "new_mv_28", "new_mvd_28","discharge_reached", "discharge_reached_sus", "ae_28", "vir_clear_5", "vir_clear_10", "vir_clear_15")
df_core <- df_core %>%
  mutate(across(all_of(char_vars), factor))

# Bar plot, missing data, each data point, core dataset
original_order <- colnames(df_core)
missing_plot <- df_core %>%
  summarise_all(~ mean(is.na(.))) %>%
  gather() %>%
  mutate(key = factor(key, levels = original_order)) %>%
  ggplot(aes(x = key, y = value)) +
  geom_bar(stat = "identity") +
  labs(x = "Columns", y = "Proportion of Missing Values", title = "Missing Data - core dataset") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ylim(0, 1)
print(missing_plot)
# Bar plot, missing data, each data point, core dataset, by arm
df_core_int <- df_core %>% 
  filter(trt == 1)
original_order <- colnames(df_core_int)
missing_plot <- df_core_int %>% # Intervention arm
  summarise_all(~ mean(is.na(.))) %>%
  gather() %>%
  mutate(key = factor(key, levels = original_order)) %>%
  ggplot(aes(x = key, y = value)) +
  geom_bar(stat = "identity") +
  labs(x = "Columns", y = "Proportion of Missing Values", title = "Missing Data - core dataset, intervention") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ylim(0, 1)
print(missing_plot)
df_core_cont <- df_core %>% 
  filter(trt == 0)
original_order <- colnames(df_core_cont)
missing_plot <- df_core_cont %>% # Control arm
  summarise_all(~ mean(is.na(.))) %>%
  gather() %>%
  mutate(key = factor(key, levels = original_order)) %>%
  ggplot(aes(x = key, y = value)) +
  geom_bar(stat = "identity") +
  labs(x = "Columns", y = "Proportion of Missing Values", title = "Missing Data - core dataset, control") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  ylim(0, 1)
print(missing_plot)

### Baseline table, by individuals with no missing data vs any missing data (or only in mort_28)
# df_core <- df_core %>% mutate(complete = ifelse(rowSums(is.na(.)) > 0, 0, 1));table(df_core$complete) # ANY missing 
df_core$resp<-ifelse(is.na(df_core$mort_28), 0, 1);table(df_core$resp) # only mort_28 missing 

# Assign variable list
vars.list <- c("resp", "age", "sympdur"
               ,"trt", "sex", "country", "icu", "ethn", "clinstatus_baseline", "vbaseline", 
               "comed_dexa", "comed_rdv", "comed_toci", "comed_ab", "comed_acoa", "comed_interferon", "comed_other", "comed_cat",
               "comorb_lung", "comorb_liver", "comorb_cvd", "comorb_aht", "comorb_dm", "comorb_obese", "comorb_smoker", "immunosupp", "any_comorb", "comorb_cat", "comorb_any", "comorb_count","comorb_autoimm","comorb_cancer", "comorb_kidney", "crp", "vl_baseline"
               , "mort_28", "mort_28_dimp", "mort_60", "death_reached","death_time", "new_mv_28", "new_mvd_28","discharge_reached", "discharge_time", "discharge_reached_sus", "discharge_time_sus", "ae_28", "ae_28_sev", "vir_clear_5", "vir_clear_10", "vir_clear_15")

# By completeness (only mort_28)
table_resp <- CreateTableOne(data = df_core, vars = vars.list[!vars.list %in% c("resp")], strata = "resp", includeNA = T, test = T, addOverall = TRUE)
# Print and display the table
capture.output(
  table_resp <- print(
    table_resp, 
    nonnormal = vars.list, 
    catDigits = 1, 
    SMD = TRUE, 
    showAllLevels = TRUE, 
    test = TRUE, 
    printToggle = FALSE, 
    missing = TRUE))
kable(table_resp, format = "markdown", table.attr = 'class="table"', caption = "By completeness (only mort_28)") %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)


### Define variables to be included in imputation set
# table(df_core$vl_baseline)
df_imp <- df_core %>% 
  select("id_pat"
         , "trt", "sex", "age" , "ethn"
         , "country", "sympdur" 
         # ,"vacc" # no info
         # , "trial", "JAKi"  # only 0
         ,"clinstatus_baseline"
         # , "vbaseline" # derived
         # , "comed_rdv" # no info
         # , "comed_toci", "comed_interferon" # no info
         #,  "comed_cat", # derived
         , "comed_dexa", "comed_ab"
         # , "comed_acoa" # no info
         , "comed_other" 
         # , "comorb_lung", "comorb_liver", "comorb_cvd", "comorb_aht", "comorb_dm", "comorb_obese",
         # "comorb_smoker", "immunosupp", "comorb_autoimm", "comorb_cancer", "comorb_kidney", "any_comorb",
         # "comorb_count",
         # "comorb_any", 
         ,"comorb_cat" # derived from above, contains most information, and needed as interaction term
         ,"crp"
         ,"vl_baseline"
         # , "sero" , "variant" # very little info
         , clinstatus_1, clinstatus_2, clinstatus_3, clinstatus_4, clinstatus_5, clinstatus_6, clinstatus_7, clinstatus_8, clinstatus_9, clinstatus_10, clinstatus_11, clinstatus_12, clinstatus_13, clinstatus_14, clinstatus_15, clinstatus_16, clinstatus_17, clinstatus_18, clinstatus_19, clinstatus_20, clinstatus_21, clinstatus_22, clinstatus_23, clinstatus_24, clinstatus_25, clinstatus_26, clinstatus_27, clinstatus_28
         # , "clinstatus_28_imp" # imputed via LOVCF above
         , "mort_28"
         # , "mort_28_dimp" # imputed deterministically
         # , "mort_60" # does not contain any additional information compared to death reached
         , "death_reached", "death_time", "new_mv_28", "new_mvd_28", "discharge_reached", "discharge_time"
         # , "discharge_reached_sus", "discharge_time_sus" # same as discharge, does not contain any addition information
         , "ae_28", "ae_28_sev", "vir_clear_5", "vir_clear_10", "vir_clear_15"
         )

# First, table and visualize missing data in various ways
# df_imp %>% 
#   ff_glimpse() # from finalfit package
df_imp %>%
  missing_plot() # from finalfit package
explanatory = c("age", 
  "clinstatus_baseline", "sex",  
  "ethn", "country", "sympdur", "comorb_cat", "comed_dexa", "comed_ab", "comed_other", "crp", "vl_baseline", "ae_28_sev")
dependent = "mort_28"
df_imp %>% # from finalfit package, missing plot
  missing_pairs(dependent, explanatory, position = "fill", )
# Second, let's explore the missingness patterns
md.pattern(df_imp[,c("mort_28", "age", 
  "clinstatus_baseline", "sex",  
  "ethn", "country", "sympdur", "comorb_cat", "comed_dexa", "comed_ab", "comed_other", "crp","vl_baseline", "ae_28_sev")], rotate.names = T)
# Third, let's explore if the variables from my substantive model plus auxiliary variables are associated with mort_28
mort28.aux <- glm(mort_28 ~ trt
            + age 
            + clinstatus_baseline
            + sex
            + ethn
            + country
            + sympdur
            + comorb_cat
            + comed_dexa
            + comed_ab
            + comed_other
            + vl_baseline
            + crp
            # + ae_28_sev
            ,family="binomial"
            ,data=df_imp)
summary(mort28.aux)
# Fourth, let's explore if they are associated with missingness of mort_28:
df_imp %>% 
  missing_compare(dependent, explanatory) %>%
    knitr::kable(row.names=FALSE, align = c("l", "l", "r", "r", "r"))
# Fifth, check age
summary(df_imp$age)
hist(df_imp$age, breaks=50) # looks fine
# Sixth, check sympdur
summary(df_imp$sympdur)
hist(df_imp$sympdur, breaks=50) # skewed -> transform
df_imp$sqsympdur=sqrt(df_imp$sympdur)
hist(df_imp$sqsympdur) # looks fine
# Seventh, check crp
summary(df_imp$crp)
hist(df_imp$crp, breaks=50) # outliers
df_imp <- df_imp %>% # truncate outliers > 500
  mutate(crptrunc = case_when(crp > 500 ~ 500,
                               TRUE ~ crp))
hist(df_imp$crptrunc)
df_imp$sqcrptrunc=sqrt(df_imp$crptrunc)
hist(df_imp$sqcrptrunc) # looks fine


### Reshape to long format
# names(df_imp)
# str(df_imp)
df_imp <- df_imp %>% # rename to differentiate between baseline clinical status and follow-up clinical statuses
  rename(clinicalstatus_baseline = clinstatus_baseline)
# reshape
df_imp_long <- df_imp %>% 
  pivot_longer(cols = starts_with("clinstatus"), names_to = "time", values_to = "clinstatus")
# names(df_imp_long)
# Convert time to numeric
df_imp_long$time <- as.numeric(gsub("clinstatus_", "", df_imp_long$time))
# class(df_imp_long$time)
# summary(df_imp_long$time)
# have clinstatus as numeric
# class(df_imp_long$clinstatus)
# table(df_imp_long$clinstatus_n)
df_imp_long$clinstatus_f <- factor(df_imp_long$clinstatus, levels = 1:6)
df_imp_long$clinstatus_n <- as.numeric(df_imp_long$clinstatus_f)
# table(df_imp_long$clinstatus_n)

### We will impute separately by treatment arm, since we have to expect an effect modification between outcome x trt over time
df_imp_long_int <- df_imp_long %>% 
  filter(trt == 1)
df_imp_long_cont <- df_imp_long %>% 
  filter(trt == 0)

## Explore distribution of clinical status over time, by arm
plot_clinstat_int <- ggplot(df_imp_long_int, aes(x = time, y = clinstatus_n)) +
  stat_summary(fun = "mean", geom = "point", color = "blue", size = 3, na.rm = TRUE) +
  geom_smooth(method = "loess", se = FALSE, color = "red", na.rm = TRUE) +
  labs(title = "Distribution of Clinical Status Over Time / Intervention",
       x = "Time",
       y = "Mean Clinical Status") +
  theme_minimal()
print(plot_clinstat_int)
plot_clinstat_cont <- ggplot(df_imp_long_cont, aes(x = time, y = clinstatus_n)) +
  stat_summary(fun = "mean", geom = "point", color = "blue", size = 3, na.rm = TRUE) +
  geom_smooth(method = "loess", se = FALSE, color = "red", na.rm = TRUE) +
  labs(title = "Distribution of Clinical Status Over Time / Control",
       x = "Time",
       y = "Mean Clinical Status") +
  theme_minimal()
print(plot_clinstat_cont)
```


# Pooled logistic regression to get adjusted cumulative incidence curves for time to death

## a) Adapt long format dataframe for primary endpoint (mortality within 28 days) as time to event outcome
```{r warning=FALSE}

K <- 28 # set time point of assessment -> might change to 60 days!

# table(df_imp_long$time, useNA = "always")
# table(df_imp_long$clinicalstatus_baseline, useNA = "always")
# table(df_imp_long$death_reached, useNA = "always")
# table(df_imp_long$clinstatus, useNA = "always")
# table(df_imp_long$clinstatus, df_imp_long$mort_28, useNA = "always")

# person-day format, whereby updated time-varying covariate (daily clinical status) and constant time-fixed covariates
# mort_28 == 1 only at day of death, before 0. 
# CAVE: keep mort_28 = NA as NA
# censor == 1 where mort_28 == NA (within 28d) and LTFU/withdrawal
# mort_28_n only NA on the day of a censored individual
# treat/trt not time-updated, keep only time-fixed, since we will not assess any per-protocol effects

df_long <- df_imp_long %>% 
  mutate(mort_28_n = case_when(mort_28 == "1" & time == death_time ~ 1, # mark the deaths at the correct time point (cave: missing)
                               mort_28 %in% c("1","0") & time <= death_time ~ 0, # refill previous to deaths with 0
                               mort_28 == "0" ~ 0)) # refill all alive with 0
df_long <- df_long %>% 
  filter((is.na(mort_28_n) & is.na(mort_28)) | (mort_28 == "1" & mort_28_n == "1") | (mort_28 == "1" & mort_28_n == "1") | (mort_28 == "0" & mort_28_n == "0") | (mort_28 == "1" & mort_28_n == "0")) # remove mort_28_n == NA (but only when not also NA in mort_28, since these are the true missing; check 80504)
df_long <- df_long %>% # mark the censored ones (part of death_time, but mort_28/mort_28_n == NA) // censor 1 day after LTFU/withdrawal!
  mutate(censor = case_when(is.na(mort_28) & is.na(mort_28_n) 
                               & death_time <= 28 
                               & time == death_time + 1 ~ 1, # mark the censored at the correct time point (cave: missing)
                            is.na(mort_28) & is.na(mort_28_n) 
                               & death_time <= 28 
                               & time <= death_time + 1 ~ 0, # refill previous to censored with 0
                            mort_28 %in% c("1", "0") & mort_28_n %in% c(1, 0)
                               ~ 0, # refill the known ones
                            ))
df_long <- df_long %>% 
  filter(!is.na(censor)) # drop all censor == NA (after censoring event)

df_long <- df_long %>% # refill the mort_28_na == NA with 0 for the days before censoring
  mutate(mort_28_n = case_when(is.na(mort_28_n) & censor == 0 ~ 0,
                               TRUE ~ mort_28_n))

# df_long %>% 
#   select(id_pat, trt, time, censor, mort_28, mort_28_n, death_reached, death_time, clinstatus, discharge_reached, discharge_time, sex, sqcrptrunc, sqsympdur) %>% 
#   # filter(id_pat == "80804") %>%
#   # filter(id_pat == "80504") %>%
#   # filter(is.na(mort_28_n)) %>%
#   # filter(is.na(censor)) %>%
#   # filter(mort_28_n == 0 & mort_28 == "1") %>%
#   # filter(is.na(mort_28)) %>%
#   View()
# table(df_long$mort_28, df_long$mort_28_n, useNA = "always") # 102 censored, 211 deaths
# table(df_long$censor, useNA = "always") # 102 censored, 211 deaths
# table(df$mort_28, useNA = "always") # 103 missing, 211 deaths

# Number of observations at each follow-up day
table(df_long$clinicalstatus_baseline, useNA="always")

df_long <- df_long %>%
  mutate(time = time-1) %>%
  mutate(timesqr = time * time)
df_long <- df_long %>%
    mutate(clinicalstatus_baseline = case_when(is.na(clinicalstatus_baseline) ~ "5", # only for X below, see rules in Notes
                                             TRUE ~ clinicalstatus_baseline))
df_long$clinicalstatus_baseline_n <- as.numeric(df_long$clinicalstatus_baseline)
# table(df_long$clinicalstatus_baseline_n, useNA = "always")
# table(df_long$clinicalstatus_baseline, useNA = "always")

```

## b) Nonparametric Kaplan-Meier estimator to construct cumulative incidence (risk) curves for the primary outcome
```{r warning=FALSE}
# Obtain Kaplan-Meier estimates

# Load required packages
if (!require("ggplot2")) install.packages("ggplot2")
library(ggplot2)
if (!require("survival")) install.packages("survival")
library(survival)
if (!require("survminer")) install.packages("survminer")
library(survminer)

# class(df_long$clinicalstatus_baseline)
# table(df_long$time, useNA = "always")
# table(df_long$clinicalstatus_baseline, useNA = "always")
# table(df_long$death_reached, useNA = "always")
# table(df_long$clinstatus, useNA = "always")

fit.km  <- survfit(Surv(time, time+1, mort_28_n) ~ trt,
                   conf.type="log-log",
                   data = df_long)

# Create cumulative incidence (risk) plot // unadjusted
plot <- ggsurvplot(
  fit.km,
  fun = "event", # plot cumulative incidence
  conf.int = TRUE, # include confidence intervals
  censor = FALSE, # don't include tick marks for events/censorings
  xlab = "Days", # label x-axis
  break.x.by = 2, # display x-axis in 1-day bins
  surv.scale = "percent", # show y-axis in %
  ylab = "Cumulative Incidence (%)", # label y-axis
  ylim = c(0,0.20), # set limits of y-axis
  legend = c(0.2, 0.8), # set legend position
  legend.labs = c("No JAKi", "JAKi"),
  legend.title = "", # set legend title to blank
  palette = c("#E7B800", "#2E9FDF")) # set colors

# Print the plot
plot

```
## c) Nonparametric KM estimator to compute 28-day risks, risk difference, and risk ratio
```{r warning=FALSE}
# Review KM survival estimates
summary(fit.km)
summary(fit.km, times = K)

### 28-day risk in the No JAKi group ###
# Risk
risk0 <- 1 - summary(fit.km, times = K)$surv[1]
# 95% CI
risk0.u <- 1 - summary(fit.km, times = K)$lower[1]
risk0.l <- 1 - summary(fit.km, times = K)$upper[1]
# Print
risk0.ci <- round(c(risk0, risk0.l, risk0.u), 3)
risk0.ci

### 28-day risk in the JAKi group ###
# Risk
risk1 <- 1- summary(fit.km, times = K)$surv[2]
# 95% CI
risk1.u <- 1- summary(fit.km, times = K)$lower[2]
risk1.l <- 1- summary(fit.km, times = K)$upper[2]
# Print
risk1.ci <- round(c(risk1, risk1.l, risk1.u), 3)
risk1.ci

### 28-day risk difference ###
rd <- risk1 - risk0
round(rd, 4)

### 28-day risk ratio ###
rr <- risk1 / risk0
round(rr, 2)

```


## d) Unadjusted parametric pooled logistic regression (mortality at day 28) and construct parametric cumulative incidence (risk) curves (without 95% CI)
```{r warning=FALSE}
# Fit pooled logistic model to estimate discrete hazards

# Include product terms between time and treatment
fit.pool <- glm(formula = mort_28_n==1 ~ trt + time + timesqr +
                  # age + clinicalstatus_baseline + ## adjustment: use standardization/IPTW as adjustment?!?
                                    I(trt*time) +
                                    I(trt*timesqr),
                family = binomial(link = 'logit'),
                data = df_long)

# Print results
summary(fit.pool)

### Transform estimates to risks at each time point in each group ###

# Create a dataset to store results
# Include all time points under each treatment level
trt0 <- data.frame(cbind(seq(0, K-1),0,(seq(0, K-1))^2))
trt1 <- data.frame(cbind(seq(0, K-1),1,(seq(0, K-1))^2))

# Set column names
colnames(trt0) <- c("time", "trt", "timesqr")
colnames(trt1) <- c("time", "trt", "timesqr")

# Extract predicted values from pooled logistic regression model
# Predicted values correspond to discrete-time hazards
trt0$p.event0 <- predict(fit.pool, trt0, type="response")
trt1$p.event1 <- predict(fit.pool, trt1, type="response")

# Estimate survival probabilities S(t) from hazards, h(t)
# S(t) = cumulative product of (1 - h(t))
trt0$surv0 <- cumprod(1 - trt0$p.event0)
trt1$surv1 <- cumprod(1 - trt1$p.event1)

# Estimate risks from survival probabilities
# Risk = 1 - S(t)
trt0$risk0 <- 1 - trt0$surv0
trt1$risk1 <- 1 - trt1$surv1

# Prepare data
graph.pred <- merge(trt0, trt1, by=c("time", "timesqr"))
# Edit data frame to reflect that risks are estimated at the END of each interval
graph.pred$time_0 <- graph.pred$time + 1
zero <- data.frame(cbind(0,0,0,0,1,0,1,0,1,0,0))
zero <- setNames(zero,names(graph.pred))
graph <- rbind(zero, graph.pred)

# Create plot (without CIs)
plot.plr <- ggplot(graph,
                   aes(x=time_0, y=risk)) + # set x and y axes
  geom_line(aes(y = risk1, # create line for JAKi group
                color = "JAKi"),
                size = 1.5) +
  geom_line(aes(y = risk0, # create line for No JAKi group
                color = "No JAKi"),
                size = 1.5) +
  xlab("Days") + # label x axis
  scale_x_continuous(limits = c(0, 28), # format x axis
                     breaks=c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28)) +
  ylab("Cumulative Incidence (%)") + # label y axis
  scale_y_continuous(limits=c(0, 0.20), # format y axis
                     breaks=c(0, 0.05, 0.1, 0.15, 0.20),
                     labels=c("0.0%", "5.0%",
                              "10.0%", "15.0%", "20.0%")) +
  theme_minimal()+ # set plot theme elements
  theme(axis.text = element_text(size=14), legend.position = c(0.2, 0.8),
        axis.line = element_line(colour = "black"),
        legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.y = element_blank())+
  font("xlab",size=14)+
  font("ylab",size=14)+
  font("legend.text",size=10)+
  scale_color_manual(values=c("#E7B800","#2E9FDF"), # set colors
                     breaks=c('No JAKi', 'JAKi'))

# Plot
plot.plr
```

## e) Unadjusted parametric pooled logistic regression (mortality at day 28) and bootstrap the 95% CI
```{r warning=FALSE}
if (!require("boot")) install.packages("boot")
library(boot)

# 28-day risk in No JAKi group
risk0.plr <- graph$risk0[which(graph$time==K-1)]
round(risk0.plr, 3)

# 28-day risk in JAKi group
risk1.plr <- graph$risk1[which(graph$time==K-1)]
round(risk1.plr, 3)

# 28-day risk difference
rd.plr <- risk1.plr - risk0.plr
round(rd.plr, 4)

# 28-day risk ratio
rr.plr <- risk1.plr / risk0.plr
round(rr.plr, 2)

### Obtain percentile-based bootstrapped 95% CIs for each quantity ###

# Create input list of ids (eligible persons)
df_long_ids <- data.frame(id_pat = unique(df_long$id_pat))

# Create a function to obtain risks, RD, and RR from each bootstrap sample
risk.boot <- function(data, indices) {
  # Select individuals into each bootstrapped sample
  ids <- data$id_pat
  boot.ids <- data.frame(id_pat = ids[indices])

  # Subset person-time data to individuals selected into the bootstrapped sample
  d <- left_join(boot.ids, df_long, by = "id_pat")

  # Fit pooled logistic model to estimate discrete hazards
  pool.boot <- glm(formula = mort_28_n==1 ~ trt + time + timesqr +
                                    I(trt*time) +
                                    I(trt*timesqr),
                family = binomial(link = 'logit'),
                data = d)

  # Create a dataset to store results
  # Include all time points under each treatment level
  trt0 <- data.frame(cbind(seq(0, K-1),0,(seq(0, K-1))^2))
  trt1 <- data.frame(cbind(seq(0, K-1),1,(seq(0, K-1))^2))

  # Set column names
  colnames(trt0) <- c("time", "trt", "timesqr")
  colnames(trt1) <- c("time", "trt", "timesqr")

  # Extract predicted values from pooled logistic regression model
  # Predicted values correspond to discrete-time hazards
  trt0$p.event0 <- predict(pool.boot, trt0, type="response")
  trt1$p.event1 <- predict(pool.boot, trt1, type="response")

  # Estimate survival probabilities S(t) from hazards, h(t)
  # S(t) = cumulative product of (1 - h(t))
  trt0$surv0 <- cumprod(1 - trt0$p.event0)
  trt1$surv1 <- cumprod(1 - trt1$p.event1)

  # Estimate risks from survival probabilities
  # Risk = 1 - S(t)
  trt0$risk0 <- 1 - trt0$surv0
  trt1$risk1 <- 1 - trt1$surv1

  # Merge data from two groups and format
  graph <- merge(trt0, trt1, by=c("time", "timesqr"))
  graph$rd <- graph$risk1-graph$risk0
  graph$rr <- graph$risk1/graph$risk0
  return(c(graph$risk0[which(graph$time==K-1)],
           graph$risk1[which(graph$time==K-1)],
           graph$rd[which(graph$time==K-1)],
           graph$rr[which(graph$time==K-1)]))
}

# Run bootstrap samples -- how many?
set.seed(1234)
risk.results <- boot(data = df_long_ids,
                     statistic = risk.boot,
                     R=10)

# Print point estimates from the original data
head(risk.results$t0)

# 95% CI for risk in No JAKi group
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 1) # create CI for first statistic (risk0) returned by boot()

# 95% CI for risk in JAKi group
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 2) # create CI for second statistic (risk1) returned by boot()

# 95% CI for risk difference
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 3) # create CI for third statistic (rd) returned by boot()

# 95% CI for risk ratio
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 4) # create CI for fourth statistic (rr) returned by boot()
```

## f) Construct unadjusted parametric cumulative incidence (risk) curves, based on pooled log reg, INCL. 95% CIs using bootstrapping
```{r warning=FALSE}
# need to do this by group individually // see hands-on 1

# Create input list of ids 
df_long_ids <- data.frame(id_pat = unique(df_long$id_pat))

### No JAKi group ###

# Create a function to obtain risk in no JAKi group at each time t from each bootstrap sample
risk.boot.0 <- function(data, indices) {
  # Select individuals into each bootstrapped sample
  ids <- data$id_pat
  boot.ids <- data.frame(id_pat = ids[indices])

  # Subset person-time data to individuals selected into the bootstrapped sample
  d <- left_join(boot.ids, df_long, by = "id_pat")

  # Fit pooled logistic model to estimate discrete hazards
  pool.boot <- glm(formula = mort_28_n==1 ~ trt + time + timesqr
                                    + I(trt*time) +
                                    I(trt*timesqr),
                family = binomial(link = 'logit'),
                data = d)

  # Create a dataset to store results
  # Include all time points under each treatment level
  trt0 <- data.frame(cbind(seq(0, K-1),0,(seq(0, K-1))^2))
  trt1 <- data.frame(cbind(seq(0, K-1),1,(seq(0, K-1))^2))

  # Set column names
  colnames(trt0) <- c("time", "trt", "timesqr")
  colnames(trt1) <- c("time", "trt", "timesqr")

  # Extract predicted values from pooled logistic regression model
  # Predicted values correspond to discrete-time hazards
  trt0$p.event0 <- predict(pool.boot, trt0, type="response")
  trt1$p.event1 <- predict(pool.boot, trt1, type="response")

  # Convert from discrete-time hazards to survival probabilities
  # S(t) = cumulative product of (1 - h(t))
  trt0$surv0 <- cumprod(1 - trt0$p.event0)
  trt1$surv1 <- cumprod(1 - trt1$p.event1)

  # Convert from survival to risks
  # Risk = 1 - S(t)
  trt0$risk0 <- 1 - trt0$surv0
  trt1$risk1 <- 1 - trt1$surv1

  # Merge data from two groups and format
  graph <- merge(trt0, trt1, by=c("time", "timesqr"))
  graph <- graph[order(graph$time),]
  return(graph$risk0) # return only control group risk
}

# Run bootstrap samples (ideally 500-1000)...
set.seed(1234)
risk.results.0 <- boot(data = df_long_ids,
                       statistic = risk.boot.0,
                       R=100)

# Combine relevant bootstrapped results into a dataframe
risk.boot.results.0 <- data.frame(cbind(risk0 = risk.results.0$t0, # Combines the initial risk estimates (risk0) 
                                        t(risk.results.0$t))) # with the transpose of the bootstrapped results (t(risk.results.0$t))

# Format bootstrapped results for plotting
risk.boot.graph.0 <- data.frame(cbind(time = seq(0, K-1), mean.0 = risk.boot.results.0$risk0), # Creates a data frame with time points and mean risk estimates; to include the mean risk estimate for the no JAKi group at each time point in the final formatted data frame risk.boot.graph.0
                                ll.0 = (apply((risk.boot.results.0)[,-1], 1, quantile, probs=0.025)), # Applies the quantile function to each row (indicated by 1) of risk.boot.results.0 (excluding the first column) and computes the 2.5th percentile for each row
                                ul.0 = (apply((risk.boot.results.0)[,-1], 1, quantile, probs=0.975)))


### JAKi group ###

# Create a function to obtain risk in JAKi group at each time t from each bootstrap sample
risk.boot.1 <- function(data, indices) {
  # Select individuals into each bootstrapped sample
  ids <- data$id_pat
  boot.ids <- data.frame(id_pat = ids[indices])

  # Subset person-time data to individuals selected into the bootstrapped sample
  d <- left_join(boot.ids, df_long, by = "id_pat")

  # Fit pooled logistic model to estimate discrete hazards
  pool.boot <- glm(formula = mort_28_n==1 ~ trt + time + timesqr +
                                    I(trt*time) +
                                    I(trt*timesqr),
                family = binomial(link = 'logit'),
                data = d)

  # Create a dataset to store results
  # Include all time points under each treatment level
  trt0 <- data.frame(cbind(seq(0, K-1),0,(seq(0, K-1))^2))
  trt1 <- data.frame(cbind(seq(0, K-1),1,(seq(0, K-1))^2))

  # Set column names
  colnames(trt0) <- c("time", "trt", "timesqr")
  colnames(trt1) <- c("time", "trt", "timesqr")

  # Extract predicted values from pooled logistic regression model
  # Predicted values correspond to discrete-time hazards
  trt0$p.event0 <- predict(pool.boot, trt0, type="response")
  trt1$p.event1 <- predict(pool.boot, trt1, type="response")

  # Convert from discrete-time hazards to survival probabilities
  # S(t) = cumulative product of (1 - h(t))
  trt0$surv0 <- cumprod(1 - trt0$p.event0)
  trt1$surv1 <- cumprod(1 - trt1$p.event1)

  # Convert from survival to risks
  # Risk = 1 - S(t)
  trt0$risk0 <- 1 - trt0$surv0
  trt1$risk1 <- 1 - trt1$surv1

  # Merge data from two groups and format
  graph <- merge(trt0, trt1, by=c("time", "timesqr"))
  graph <- graph[order(graph$time),]
  return(graph$risk1)
}

# Run bootstrap samples (ideally 500-1000)...
set.seed(1234)
risk.results.1 <- boot(data = df_long_ids,
                       statistic = risk.boot.1,
                       R=100)


# Combine relevant bootstrapped results into a dataframe
risk.boot.results.1 <- data.frame(cbind(risk1 = risk.results.1$t0,
                                        t(risk.results.1$t)))
# Format bootstrapped results for plotting
risk.boot.graph.1 <- data.frame(cbind(time = seq(0, K-1), mean.1 = risk.boot.results.1$risk1),
                                ll.1 = (apply((risk.boot.results.1)[,-1], 1, quantile, probs=0.025)),
                                ul.1 = (apply((risk.boot.results.1)[,-1], 1, quantile, probs=0.975)))


# Prepare data
risk.boot.graph.pred <- merge(risk.boot.graph.0, risk.boot.graph.1, by= "time")

# Edit data frame to reflect that risks are estimated at the END of each interval
risk.boot.graph.pred$time_0 <- risk.boot.graph.pred$time + 1
zero <- data.frame(cbind(0,0,0,0,0,0,0,0))
zero <- setNames(zero,names(risk.boot.graph.pred))
risk.boot.graph <- rbind(zero, risk.boot.graph.pred)

# Create plot
plot.plr.ci <- ggplot(risk.boot.graph,
                      aes(x=time_0)) + # set x and y axes
  geom_line(aes(y = mean.1, # create line for JAKi group
                color = "JAKi"),
                size = 1.5) +
  geom_ribbon(aes(ymin = ll.1, ymax = ul.1, fill = "JAKi"), alpha = 0.4) +
  geom_line(aes(y = mean.0, # create line for no vaccine group
                color = "No JAKi"),
                size = 1.5) +
  geom_ribbon(aes(ymin = ll.0, ymax = ul.0, fill = "No JAKi"), alpha=0.4) +
  xlab("Days") + # label x axis
  scale_x_continuous(limits = c(0, 28), # format x axis
                     breaks=c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28)) +
  ylab("Cumulative Incidence (%)") + # label y axis
  scale_y_continuous(limits=c(0, 0.20), # format y axis
                     breaks=c(0, 0.05, 0.10, 0.15, 0.20),
                     labels=c("0.0%", "5.0%",
                              "10.0%", "15.0%", "20.0%")) +
  theme_minimal()+ # set plot theme elements
  theme(axis.text = element_text(size=14), legend.position = c(0.2, 0.8),
        axis.line = element_line(colour = "black"),
        legend.title = element_blank(),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.y = element_blank())+
  font("xlab",size=14)+
  font("ylab",size=14)+
  font("legend.text",size=10)+
  scale_color_manual(values=c("#E7B800", # set colors
                              "#2E9FDF"),
                     breaks=c('No JAKi',
                              'JAKi')) +
  scale_fill_manual(values=c("#E7B800", # set colors
                              "#2E9FDF"),
                     breaks=c('No JAKi',
                              'JAKi'))

# Plot
plot.plr.ci

```

## g) Getting HR from pooled log reg to compare (First, from the pooled log reg. Second, from coxph long format. Third, from coxph wide format)
```{r warning=FALSE}
## FIRST
# Pooled logistic model // without product terms with time
fit.pool2 <- glm(formula = mort_28_n==1 ~ trt + time + timesqr,
                 family = binomial(link = 'logit'),
                 data = df_long)
summary(fit.pool2)

# Exponentiate coefficient for random assignment
round(exp(summary(fit.pool2)$coef["trt","Estimate"]), 2)


# Cox proportional hazards model for comparison
fit.cox <- coxph(Surv(time, time+1, mort_28_n) ~ trt,
                 data = df_long)
summary(fit.cox)

# Exponentiate coefficient for random assignment
round(exp(summary(fit.cox)$coef["trt","coef"]), 2)


## SECOND
# We can also fit this Cox proportional hazards model using only one line of data per person (i.e., a wide formatted dataset)
# Then, we need two new variables, surv_time and mort_28_n_any (same as death_time, death_reached as below but only within 28d)

# Create hosp_any, an indicator of any hospitalization over the 28-day follow-up period
df_long <- df_long %>%
  dplyr::group_by(id_pat) %>%
  dplyr::mutate(
    mort_28_n_any = ifelse(is.na(mort_28_n), NA, max(mort_28_n, na.rm = T))) %>%
  dplyr::ungroup()
table(df_long$mort_28_n_any[which(df_long$time==0)])

# Create surv_time, minimum of time of event, censoring due to LTFU, death, or administrative censoring
df_long <- df_long %>%
  dplyr::group_by(id_pat) %>%
  dplyr::mutate(
    surv_time = max(time)) %>%
  dplyr::ungroup()
summary(df_long$surv_time[which(df_long$time==0)])

## THIRD
# Fit Cox model with wide formatted data
fit.cox <- coxph(Surv(surv_time, mort_28_n_any) ~ trt,
                 data = df_long[which(df_long$time==0),])
summary(fit.cox)

# Exponentiate coefficient for random assignment
round(exp(summary(fit.cox)$coef["trt","coef"]), 2)


# Fit Cox model with wide formatted data, ORIGINAL data - cave: longer fup time beyond 28 days!
fit.cox2 <- df %>% 
  coxph(Surv(death_time, death_reached) ~ trt 
        # + age + clinstatus_baseline
        , data =.)
summary(fit.cox2)

# Exponentiate coefficient for random assignment
round(exp(summary(fit.cox2)$coef["trt","coef"]), 2)

```

## h) Adjusted parametric pooled logistic regression (mortality at day 28), using Standardization, and bootstrap the 95% CI
```{r warning=FALSE}
### Standardization ###
# Load required packages
if (!require("speedglm")) install.packages("speedglm")
library(speedglm)
if (!require("splitstackshape")) install.packages("splitstackshape")
library("splitstackshape")

# Fit pooled logistic regression model with covariates
gf.model <- speedglm(formula = mort_28_n==1 ~ trt + time + timesqr
                     + age 
                     + as.factor(clinicalstatus_baseline) 
                     + I(trt*time) + I(trt*timesqr),
                     family = binomial(link = 'logit'),
                    data = df_long)
                    # data = df_long[df_long$censor==0,]) ## makes no difference
# summary(gf.model)

### Transform estimates to risks at each time point in each group ###

# Create dataset with all time points for each individual under each treatment level, starting at time == 0 (not 1)
treat0 <- expandRows(df_long[which(df_long$time==0),], count=K, count.is.col=F)
treat0$time <- rep(seq(0, K-1), nrow(df_long[which(df_long$time==0),]))
treat0$timesqr <- treat0$time^2
# Under no JAKi ("force" everyone to be untreated)
treat0$trt <- 0
# Under JAKi ("force" everyone to be treated)
treat1 <- treat0
treat1$trt <- 1

# Extract predicted values from pooled logistic regression model for each person-time row
# Predicted values correspond to discrete-time hazards
treat0$p.event0 <- predict(gf.model, treat0, type="response")
treat1$p.event1 <- predict(gf.model, treat1, type="response")

# Obtain predicted survival probabilities from discrete-time hazards
treat0.surv <- treat0 %>% group_by(id_pat) %>% mutate(surv0 = cumprod(1 - p.event0)) %>% ungroup()
treat1.surv <- treat1 %>% group_by(id_pat) %>% mutate(surv1 = cumprod(1 - p.event1)) %>% ungroup()

# Estimate risks from survival probabilities
# Risk = 1 - S(t)
treat0.surv$risk0 <- 1 - treat0.surv$surv0
treat1.surv$risk1 <- 1 - treat1.surv$surv1

# Get the mean in each treatment group at each time point from 0 to 27 (28 time points in total)
risk0 <- aggregate(treat0.surv[c("trt", "time", "risk0")], by=list(treat0.surv$time), FUN=mean)[c("trt", "time", "risk0")]
risk1 <- aggregate(treat1.surv[c("trt", "time", "risk1")], by=list(treat1.surv$time), FUN=mean)[c("trt", "time", "risk1")]

# Prepare data
graph.pred <- merge(risk0, risk1, by=c("time"))
# Edit data frame to reflect that risks are estimated at the END of each interval
graph.pred$time_0 <- graph.pred$time + 1
zero <- data.frame(cbind(0,0,0,1,0,0))
zero <- setNames(zero,names(graph.pred))
graph <- rbind(zero, graph.pred)

### Use pooled logistic regression estimates to compute causal estimates ###
# 28-day risk in no JAKi group
risk0.plr <- graph$risk0[which(graph$time==K-1)]
risk0.plr
# 28-day risk in JAKi group
risk1.plr <- graph$risk1[which(graph$time==K-1)]
risk1.plr
# 28-day risk difference
rd.plr <- risk1.plr - risk0.plr
rd.plr
# 28-day risk ratio
rr.plr <- risk1.plr / risk0.plr
rr.plr

### Bootstrapping ###

### Obtain percentile-based bootstrapped 95% CIs for each quantity ###

# Create input list of ids 
df_long_ids <- data.frame(id_pat = unique(df_long$id_pat))

# Create a function to obtain risks, RD, and RR from each bootstrap sample
std.boot <- function(data, indices) {
  # Select individuals into each bootstrapped sample
  ids <- data$id_pat
  boot.ids <- data.frame(id_pat = ids[indices])

  # Subset person-time data to individuals selected into the bootstrapped sample
  d <- left_join(boot.ids, df_long, by = "id_pat")

  # Fit pooled logistic model to estimate discrete hazards // STANDARDIZATION
  fit.pool1 <- speedglm(formula = mort_28_n==1 ~ trt + time + timesqr
                     + age + as.factor(clinicalstatus_baseline) +
                       I(trt*time) + I(trt*timesqr),
                     family = binomial(link = 'logit'),
                    data = d)

  # Create dataset with all time points for each individual under each treatment level
  treat0 <- expandRows(d[which(d$time==0),], count=K, count.is.col=F) ####### CAVE: RUINS THE TIME-UPDATED CLINSTATUS!!!
  treat0$time <- rep(seq(0, K-1), nrow(d[which(d$time==0),]))
  treat0$timesqr <- treat0$time^2

  # Create "trt" variable under no baseline JAKi
  treat0$trt <- 0

  # Create "trt" variable under baseline JAKi
  treat1 <- treat0
  treat1$trt <- 1

  # Extract predicted values from pooled logistic regression model for each person-time row
  # Predicted values correspond to discrete-time hazards
  treat0$p.event0 <- predict(fit.pool1, treat0, type="response")
  treat1$p.event1 <- predict(fit.pool1, treat1, type="response")
  # The above creates a person-time dataset where we have predicted discrete-time hazards
  # For each person-time row in the dataset

  # Obtain predicted survival probabilities from discrete-time hazards
  treat0.surv <- treat0 %>% group_by(id_pat) %>% mutate(surv0 = cumprod(1 - p.event0)) %>% ungroup()
  treat1.surv <- treat1 %>% group_by(id_pat) %>% mutate(surv1 = cumprod(1 - p.event1)) %>% ungroup()

  # Estimate risks from survival probabilities
  # Risk = 1 - S(t)
  treat0.surv$risk0 <- 1 - treat0.surv$surv0
  treat1.surv$risk1 <- 1 - treat1.surv$surv1

  # Get the mean in each treatment group at each time point from 0 to 27 (28 time points in total)
  risk0 <- aggregate(treat0.surv[c("trt", "time", "risk0")], by=list(treat0.surv$time), FUN=mean)[c("trt", "time", "risk0")]
  risk1 <- aggregate(treat1.surv[c("trt", "time", "risk1")], by=list(treat1.surv$time), FUN=mean)[c("trt", "time", "risk1")]

  # Prepare data
  graph.pred <- merge(risk0, risk1, by=c("time"))
  # Edit data frame to reflect that risks are estimated at the END of each interval
  graph.pred$time_0 <- graph.pred$time + 1
  zero <- data.frame(cbind(0,0,0,1,0,0))
  zero <- setNames(zero,names(graph.pred))
  graph <- rbind(zero, graph.pred)

  graph$rd <- graph$risk1-graph$risk0
  graph$rr <- graph$risk1/graph$risk0
  return(c(graph$risk0[which(graph$time==K-1)],
           graph$risk1[which(graph$time==K-1)],
           graph$rd[which(graph$time==K-1)],
           graph$rr[which(graph$time==K-1)]))

}

# Run bootstrap samples
set.seed(1234)
risk.results <- boot(data = df_long_ids,
                     statistic = std.boot,
                     R=5)


# Print point estimates from the original data
head(risk.results$t0)

# 95% CI for risk in no JAKi arm
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 1) # create CI for first statistic (risk0) returned by boot()

# 95% CI for risk in JAKi arm
print(rd)
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 2) # create CI for second statistic (risk1) returned by boot()

# 95% CI for risk difference
print(rr)
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 3) # create CI for third statistic (rd) returned by boot()

# 95% CI for risk ratio
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 4) # create CI for fourth statistic (rr) returned by boot()

```

## i) Construct adjusted parametric cumulative incidence (risk) curves, based on pooled log reg with Standardization, INCL. 95% CIs using bootstrapping
```{r warning=FALSE}
# need to do this by group individually

### No JAKi group ###

# Create input list of ids (eligible persons)
df_long_ids <- data.frame(id_pat = unique(df_long$id_pat))

# Create a function to obtain risk in no vaccine group at each time t from each bootstrap sample
std.boot.0 <- function(data, indices) {
  # Select individuals into each bootstrapped sample
  ids <- data$id_pat
  boot.ids <- data.frame(id_pat = ids[indices])

  # Subset person-time data to individuals selected into the bootstrapped sample
  d <- left_join(boot.ids, df_long, by = "id_pat")

  # Fit pooled logistic model to estimate discrete hazards
  fit.pool1 <- speedglm(formula = mort_28_n==1 ~ trt + time + timesqr
                     + age + as.factor(clinicalstatus_baseline) 
                     + I(trt*time) + I(trt*timesqr),
                     family = binomial(link = 'logit'),
                    data = df_long)
  
  # Create dataset with all time points for each individual under each treatment level
  treat0 <- expandRows(df_long[which(df_long$time==0),], count=K, count.is.col=F) ####### CAVE: RUINS THE TIME-UPDATED CLINSTATUS!!!
  treat0$time <- rep(seq(0, K-1), nrow(df_long[which(df_long$time==0),]))
  treat0$timesqr <- treat0$time^2

  # Create "trt" variable under no baseline JAKi
  treat0$trt <- 0

  # Create "trt" variable under baseline JAKi
  treat1 <- treat0
  treat1$trt <- 1
  
  # Extract predicted values from pooled logistic regression model for each person-time row
  # Predicted values correspond to discrete-time hazards
  treat0$p.event0 <- predict(fit.pool1, treat0, type="response")
  treat1$p.event1 <- predict(fit.pool1, treat1, type="response")
  # The above creates a person-time dataset where we have predicted discrete-time hazards
  # For each person-time row in the dataset

  # Obtain predicted survival probabilities from discrete-time hazards
  treat0.surv <- treat0 %>% group_by(id_pat) %>% mutate(surv0 = cumprod(1 - p.event0)) %>% ungroup()
  treat1.surv <- treat1 %>% group_by(id_pat) %>% mutate(surv1 = cumprod(1 - p.event1)) %>% ungroup()

  # Estimate risks from survival probabilities
  # Risk = 1 - S(t)
  treat0.surv$risk0 <- 1 - treat0.surv$surv0
  treat1.surv$risk1 <- 1 - treat1.surv$surv1

  # Get the mean in each treatment group at each time point from 0 to 27 (28 time points in total)
  risk0 <- aggregate(treat0.surv[c("trt", "time", "risk0")], by=list(treat0.surv$time), FUN=mean)[c("trt", "time", "risk0")]
  risk1 <- aggregate(treat1.surv[c("trt", "time", "risk1")], by=list(treat1.surv$time), FUN=mean)[c("trt", "time", "risk1")]

  # Prepare data
  
  # graph <- merge(risk0, risk1, by=c("time"))
  # graph <- graph[order(graph$time),]
  # return(graph$risk0) # return only control group risk  
  
  graph.pred <- merge(risk0, risk1, by=c("time"))
  # Edit data frame to reflect that risks are estimated at the END of each interval
  graph.pred$time_0 <- graph.pred$time + 1
  zero <- data.frame(cbind(0,0,0,1,0,0))
  zero <- setNames(zero,names(graph.pred))
  graph <- rbind(zero, graph.pred)
  # graph <- graph[order(graph$time),]

  return(graph$risk0) # return only control group risk
  # return(graph$risk0[which(graph$time==K-1)])
  
}

# Run bootstrap samples (ideally 500-1000)...
set.seed(1234)
std.results.0 <- boot(data = df_long_ids,
                       statistic = std.boot.0,
                       R=10)

# Combine relevant bootstrapped results into a dataframe
std.boot.results.0 <- data.frame(cbind(risk0 = std.results.0$t0,
                                        t(std.results.0$t)))
# Format bootstrapped results for plotting
std.boot.graph.0 <- data.frame(cbind(time = seq(0, K-1), mean.0 = std.boot.results.0$risk0),
                                ll.0 = (apply((std.boot.results.0)[,-1], 1, quantile, probs=0.025)), ####### CAVE: ADAPT
                                ul.0 = (apply((std.boot.results.0)[,-1], 1, quantile, probs=0.975))) ####### CAVE: ADAPT


### JAKi group ###

# Create input list of ids (eligible persons)
df_long_ids <- data.frame(id_pat = unique(df_long$id_pat))

# Create a function to obtain risk in JAKi group at each time t from each bootstrap sample
std.boot.1 <- function(data, indices) {
  # Select individuals into each bootstrapped sample
  ids <- data$id_pat
  boot.ids <- data.frame(id_pat = ids[indices])

  # Subset person-time data to individuals selected into the bootstrapped sample
  d <- left_join(boot.ids, df_long, by = "id_pat")

  # Fit pooled logistic model to estimate discrete hazards
  fit.pool1 <- speedglm(formula = mort_28_n==1 ~ trt + time + timesqr
                     # + age + as.factor(clinicalstatus_baseline) 
                     + I(trt*time) + I(trt*timesqr),
                     family = binomial(link = 'logit'),
                    data = d)

  # Create dataset with all time points for each individual under each treatment level
  treat0 <- expandRows(d[which(d$time==0),], count=K, count.is.col=F) ####### CAVE: RUINS THE TIME-UPDATED CLINSTATUS!!!
  treat0$time <- rep(seq(0, K-1), nrow(d[which(d$time==0),]))
  treat0$timesqr <- treat0$time^2

  # Create "trt" variable under no baseline JAKi
  treat0$trt <- 0

  # Create "trt" variable under baseline JAKi
  treat1 <- treat0
  treat1$trt <- 1
  
  # Extract predicted values from pooled logistic regression model for each person-time row
  # Predicted values correspond to discrete-time hazards
  treat0$p.event0 <- predict(fit.pool1, treat0, type="response")
  treat1$p.event1 <- predict(fit.pool1, treat1, type="response")
  # The above creates a person-time dataset where we have predicted discrete-time hazards
  # For each person-time row in the dataset

  # Obtain predicted survival probabilities from discrete-time hazards
  treat0.surv <- treat0 %>% group_by(id_pat) %>% mutate(surv0 = cumprod(1 - p.event0)) %>% ungroup()
  treat1.surv <- treat1 %>% group_by(id_pat) %>% mutate(surv1 = cumprod(1 - p.event1)) %>% ungroup()

  # Estimate risks from survival probabilities
  # Risk = 1 - S(t)
  treat0.surv$risk0 <- 1 - treat0.surv$surv0
  treat1.surv$risk1 <- 1 - treat1.surv$surv1

  # Get the mean in each treatment group at each time point from 0 to 27 (28 time points in total)
  risk0 <- aggregate(treat0.surv[c("trt", "time", "risk0")], by=list(treat0.surv$time), FUN=mean)[c("trt", "time", "risk0")]
  risk1 <- aggregate(treat1.surv[c("trt", "time", "risk1")], by=list(treat1.surv$time), FUN=mean)[c("trt", "time", "risk1")]

  # Prepare data
  graph.pred <- merge(risk0, risk1, by=c("time"))
  # Edit data frame to reflect that risks are estimated at the END of each interval
  graph.pred$time_0 <- graph.pred$time + 1
  zero <- data.frame(cbind(0,0,0,1,0,0))
  zero <- setNames(zero,names(graph.pred))
  graph <- rbind(zero, graph.pred)

  return(graph$risk1) # return only intervention group risk
}

# Run bootstrap samples (ideally 500-1000)...
set.seed(1234)
std.results.1 <- boot(data = df_long_ids,
                       statistic = std.boot.1,
                       R=10)


# Combine relevant bootstrapped results into a dataframe
std.boot.results.1 <- data.frame(cbind(risk1 = std.results.1$t0,
                                        t(std.results.1$t)))
# Format bootstrapped results for plotting
std.boot.graph.1 <- data.frame(cbind(time = seq(0, K-1), mean.1 = std.boot.results.1$risk1),
                                ll.1 = (apply((std.boot.results.1)[,-1], 1, quantile, probs=0.025)), ####### CAVE: ADAPT
                                ul.1 = (apply((std.boot.results.1)[,-1], 1, quantile, probs=0.975))) ####### CAVE: ADAPT


# Prepare data
std.boot.graph.pred <- merge(std.boot.graph.0, std.boot.graph.1, by= "time")
# Edit data frame to reflect that risks are estimated at the END of each interval
std.boot.graph.pred$time_0 <- std.boot.graph.pred$time + 1
zero <- data.frame(cbind(0,0,0,0,0,0,0,0))
zero <- setNames(zero,names(std.boot.graph.pred))
std.boot.graph <- rbind(zero, std.boot.graph.pred)

# # Create plot ### work on the PLOT 
# plot.plr.std.ci <- ggplot(std.boot.graph,
#                       aes(x=time_0)) + # set x and y axes
#   geom_line(aes(y = mean.1, # create line for JAKi group
#                 color = "JAKi"),
#                 size = 1.5) +
#   geom_ribbon(aes(ymin = ll.1, ymax = ul.1, fill = "JAKi"), alpha = 0.4) +
#   geom_line(aes(y = mean.0, # create line for no vaccine group
#                 color = "No JAKi"),
#                 size = 1.5) +
#   geom_ribbon(aes(ymin = ll.0, ymax = ul.0, fill = "No JAKi"), alpha=0.4) +
#   xlab("Days") + # label x axis
#   scale_x_continuous(limits = c(0, 28), # format x axis
#                      breaks=c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28)) +
#   ylab("Cumulative Incidence (%)") + # label y axis
#   scale_y_continuous(limits=c(0, 0.20), # format y axis
#                      breaks=c(0, 0.05, 0.10, 0.15, 0.20),
#                      labels=c("0.0%", "5.0%",
#                               "10.0%", "15.0%", "20.0%")) +
#   theme_minimal()+ # set plot theme elements
#   theme(axis.text = element_text(size=14), legend.position = c(0.2, 0.8),
#         axis.line = element_line(colour = "black"),
#         legend.title = element_blank(),
#         panel.grid.major.x = element_blank(),
#         panel.grid.minor.x = element_blank(),
#         panel.grid.minor.y = element_blank(),
#         panel.grid.major.y = element_blank())+
#   font("xlab",size=14)+
#   font("ylab",size=14)+
#   font("legend.text",size=10)+
#   scale_color_manual(values=c("#E7B800", # set colors
#                               "#2E9FDF"),
#                      breaks=c('No JAKi',
#                               'JAKi')) +
#   scale_fill_manual(values=c("#E7B800", # set colors
#                               "#2E9FDF"),
#                      breaks=c('No JAKi',
#                               'JAKi'))
# 
# # Plot
# plot.plr.std.ci

```

## j) Censoring due to LTFU/withdrawal, using IPCW
```{r warning=FALSE}
### Fit a pooled logistic model for the denominator of the inverse probability weights for censoring due to loss to follow-up ###

# Disable printing results in scientific notation
options(scipen=999)

## create the lagged variable for clinstatus
df_long <- df_long %>%
  group_by(id_pat) %>%
  arrange(time) %>%
  mutate(clinstatus_lag = lag(clinstatus_n, n = 1, order_by = time)) %>%
  mutate(clinstatus_lag = replace_na(clinstatus_lag, 0))

psc.denom.c <- speedglm(censor == 0 ~ time + timesqr # Follow-up time modeled using linear and quadratic terms
                   + as.factor(trt) # treatment variable 
                   + as.factor(clinstatus_lag) # time-varying covariates
                   + age + as.factor(sex) # baseline covariates
                   + as.factor(ethn)
                   # + as.factor(comed_dexa) # add missing indicator? Can't have missing data
                   + as.factor(comorb_cat)
                   ,
                   family=binomial(link="logit"),
                   data=df_long)
# summary(psc.denom.c)

# Obtain predicted probabilities
df_long$psc.denom.c <- predict(psc.denom.c, df_long, type="response")

### Fit pooled logistic model for the numerator of the stabilized weights ###
psc.num.c <- speedglm(censor==0 ~ time + timesqr # Follow-up time modeled using linear and quadratic terms
                   + as.factor(trt), # treatment variable 
                 family = binomial(link="logit"),
                 data=df_long)
# summary(psc.num.c)

# Obtain predicted probabilities
df_long$psc.num.c <- predict(psc.num.c, df_long, type="response")

### Estimate each individual's time-varying stabilized inverse probability weight for censoring due to loss to follow-up ###

# Take the cumulative product at each time point
df_long <- df_long %>%
  group_by(id_pat) %>%
  mutate(
    sw_c = cumprod(psc.num.c)/cumprod(psc.denom.c)
  ) %>%
  ungroup()

# df_long %>%
#   filter(id_pat == "80504" | id_pat == "80804") %>%
#   View()
# unique(df_long$sw_c, useNA = "always")

# df_long %>%
#   filter(is.na(sw_c)) %>%
#   View()

## Now, we could multiply/add the treatment weights

### Truncate the weights at the 99th percentile ###
threshold_99 <- quantile(df_long$sw_c, 0.99)
df_long$sw_c_99 <- df_long$sw_c
df_long$sw_c_99[df_long$sw_c_99 > threshold_99] <- threshold_99

### Check distributions of weights ###
summary(df_long$sw_c_99)
sd(df_long$sw_c_99)


### Fit weighted pooled logistic regression with final truncated weights ###

# Include product terms between time and treatment
fit.pool <- glm(formula = mort_28_n==1 ~ trt + time + timesqr +
                  I(trt*time) +
                  I(trt*timesqr),
                family = binomial(link = 'logit'),
                data = df_long,
                weights = sw_c_99)

# Print results
# summary(fit.pool)

# Create a dataset to store results
# Include all time points under each treatment level
trt0 <- data.frame(cbind(seq(0, K-1),0,(seq(0, K-1))^2))
trt1 <- data.frame(cbind(seq(0, K-1),1,(seq(0, K-1))^2))

# Set column names
colnames(trt0) <- c("time", "trt", "timesqr")
colnames(trt1) <- c("time", "trt", "timesqr")

# Extract predicted values from pooled logistic regression model
# Predicted values correspond to discrete-time hazards
trt0$p.event0 <- predict(fit.pool, trt0, type="response")
trt1$p.event1 <- predict(fit.pool, trt1, type="response")

# Estimate survival probabilities from hazards
# S(t) = cumulative product of (1 - h(t))
trt0$surv0 <- cumprod(1 - trt0$p.event0)
trt1$surv1 <- cumprod(1 - trt1$p.event1)

# Estimate risks from survival probabilities
# Risk = 1 - S(t)
trt0$risk0 <- 1 - trt0$surv0
trt1$risk1 <- 1 - trt1$surv1

# Prepare data to estimate RD and RR - merge data from two treatment groups
graph.pred <- merge(trt0, trt1, by=c("time", "timesqr"))
# Edit data frame to reflect that risks are estimated at the END of each interval
graph.pred$time_0 <- graph.pred$time + 1
zero <- data.frame(cbind(0,0,0,0,1,0,1,0,1,0,0))
zero <- setNames(zero,names(graph.pred))
graph <- rbind(zero, graph.pred)

### Use pooled logistic regression estimates to compute causal estimates ###

# 28-day risk in control
risk0 <- graph$risk0[which(graph$time==K-1)]
risk0

# 28-day risk in intervention
risk1 <- graph$risk1[which(graph$time==K-1)]
risk1

# 28-day risk difference
rd <- risk1 - risk0
rd

# 28-day risk ratio
rr <- risk1 / risk0
rr



### Bootstrapping ###
if (!require("data.table")) install.packages("data.table")
library(data.table)

  # if (!require("tableone")) install.packages("tableone")
  # library(tableone)
  # if (!require("ggplot2")) install.packages("ggplot2")
  # library(ggplot2)
  # if (!require("boot")) install.packages("boot")
  # library(boot)
  # if (!require("dplyr")) install.packages("dplyr")
  # library(dplyr)
  # if (!require("Hmisc")) install.packages("Hmisc")
  # library(Hmisc)

# Create input list of ids (eligible persons)
df_long_ids <- data.frame(id_pat = unique(df_long$id_pat))

# Create a function to obtain risks, RD, and RR from each bootstrap sample
ipcw.boot <- function(data, indices){
  # Select individuals into each bootstrapped sample
  ids <- data$id_pat
  boot.ids <- data.frame(id_pat = ids[indices])
  boot.ids$bid <- 1:nrow(boot.ids)

  # Subset person-time data to individuals selected into the bootstrapped sample
  d <- as.data.table(left_join(boot.ids, df_long, by = "id_pat"))

  # Weights for censoring due to loss to follow-up // DENOMINATOR
  psc.denom.c <- glm(censor == 0 ~ time + timesqr # Follow-up time modeled using linear and quadratic terms
                   + as.factor(trt) # treatment variable 
                   + as.factor(clinstatus_lag) # time-varying covariates
                   + age + as.factor(sex) # baseline covariates
                   + as.factor(ethn)
                   # + as.factor(comed_dexa) # add missing indicator? Can't have missing data
                   + as.factor(comorb_cat)
                   ,
                   family=binomial(link="logit"),
                   data=d)
  d$psc.denom.c <- predict(psc.denom.c, d, type="response")
  
  # Fit pooled logistic model for the numerator of the stabilized weights ###
  psc.num.c <- glm(censor==0 ~ time + timesqr # Follow-up time modeled using linear and quadratic terms
                   + as.factor(trt), # treatment variable 
                 family = binomial(link="logit"),
                 data=d)
  d$psc.num.c <- predict(psc.num.c, d, type="response")
  
  # Take the cumulative product at each time point
  d <- d %>% arrange(bid, time)
  d <- d %>%
    group_by(bid) %>%
  mutate(
    sw_c_boot = cumprod(psc.num.c)/cumprod(psc.denom.c)
  ) %>%
  ungroup()
  
  ### Truncate the weights at the 99th percentile ###
  threshold_99_boot <- quantile(d$sw_c_boot, 0.99)
  d$sw_c_boot_99 <- d$sw_c_boot
  d$sw_c_boot_99[d$sw_c_boot_99 > threshold_99_boot] <- threshold_99_boot
  
  # Include product terms between time and treatment
  fit.pool <- glm(formula = mort_28_n==1 ~ trt + time + timesqr +
                  I(trt*time) +
                  I(trt*timesqr),
                family = binomial(link = 'logit'),
                data = d,
                weights = sw_c_boot_99)

  # Create a dataset to store results
  # Include all time points under each treatment level
  trt0 <- data.frame(cbind(seq(0, K-1),0,(seq(0, K-1))^2))
  trt1 <- data.frame(cbind(seq(0, K-1),1,(seq(0, K-1))^2))
  
  # Set column names
  colnames(trt0) <- c("time", "trt", "timesqr")
  colnames(trt1) <- c("time", "trt", "timesqr")
  
  # Extract predicted values from pooled logistic regression model
  # Predicted values correspond to discrete-time hazards
  trt0$p.event0 <- predict(fit.pool, trt0, type="response")
  trt1$p.event1 <- predict(fit.pool, trt1, type="response")
  
  # Estimate survival probabilities from hazards
  # S(t) = cumulative product of (1 - h(t))
  trt0$surv0 <- cumprod(1 - trt0$p.event0)
  trt1$surv1 <- cumprod(1 - trt1$p.event1)
  
  # Estimate risks from survival probabilities
  # Risk = 1 - S(t)
  trt0$risk0 <- 1 - trt0$surv0
  trt1$risk1 <- 1 - trt1$surv1
  
  # Prepare data to estimate RD and RR - merge data from two treatment groups
  graph.pred <- merge(trt0, trt1, by=c("time", "timesqr"))
  # Edit data frame to reflect that risks are estimated at the END of each interval
  graph.pred$time_0 <- graph.pred$time + 1
  zero <- data.frame(cbind(0,0,0,0,1,0,1,0,1,0,0))
  zero <- setNames(zero,names(graph.pred))
  graph <- rbind(zero, graph.pred)

  graph$rd <- graph$risk1-graph$risk0
  graph$rr <- graph$risk1/graph$risk0
  return(c(graph$risk0[which(graph$time==K-1)],
           graph$risk1[which(graph$time==K-1)],
           graph$rd[which(graph$time==K-1)],
           graph$rr[which(graph$time==K-1)]))
}


# Run bootstrap samples
set.seed(1234)
risk.results <- boot(data = df_long_ids,
                     statistic = ipcw.boot,
                     R=100)

# Print point estimates from the original data
head(risk.results$t0)

# 95% CI for risk in CONTROL group
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 1) # create CI for first statistic (risk0) returned by boot()

# 95% CI for risk in INTERVENTION group
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 2) # create CI for second statistic (risk1) returned by boot()

# 95% CI for risk difference
print(rd)
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 3) # create CI for third statistic (rd) returned by boot()

# 95% CI for risk ratio
print(rr)
boot.ci(risk.results,
        conf = 0.95,
        type = "perc",
        index = 4) # create CI for fourth statistic (rr) returned by boot()

### Construct parametric risk curves in each treatment group ###


# Create plot (without CIs)
plot.ipcw <- ggplot(graph,
                   aes(x=time_0, y=risk)) + # set x and y axes
  geom_line(aes(y = risk0, # create line for arm 1
                color = "No JAKi"),
            size = 1.5) +
  geom_line(aes(y = risk1, # create line for arm 2
                color = "JAKi"),
            size = 1.5) +
  xlab("Days") + # label x axis
    scale_x_continuous(limits = c(0, 28), # format x axis
                     breaks=c(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28)) +
  ylab("Cumulative Incidence (%)") + # label y axis
  scale_y_continuous(limits=c(0, 0.20), # format y axis
                     breaks=c(0, 0.05, 0.10, 0.15, 0.20),
                     labels=c("0.0%", "5.0%",
                              "10.0%", "15.0%", "20.0%")) +
  theme_minimal()+ # set plot theme elements
  theme(axis.text = element_text(size=14),
        axis.title = element_text(size=14),
        axis.line = element_line(colour = "black"),
        legend.position = c(0.7, 0.8),
        legend.title = element_blank(),
        legend.text = element_text(size=10),
        panel.grid.major.x = element_blank(),
        panel.grid.minor.x = element_blank(),
        panel.grid.minor.y = element_blank(),
        panel.grid.major.y = element_blank())+
  scale_color_manual(values=c("#E7B800","#2E9FDF"), # set colors
                     breaks=c('No JAKi',
                              'JAKi'))

# Plot
plot.ipcw

```

# Multiple imputation
```{r eval = FALSE}
#### INTERVENTION group
## jomo only accepts numeric or factors, check and adapt
# str(df_imp_long_int)
df_imp_long_int$timesq <- sqrt(df_imp_long_int$time) # see X below
df_imp_long_int <- df_imp_long_int %>% 
    mutate(clinicalstatus_baseline = case_when(is.na(clinicalstatus_baseline) ~ "5", # only for X below, see rules in Notes
                                             TRUE ~ clinicalstatus_baseline))
attach(df_imp_long_int)
Y2<-data.frame(mort_28 # level 2 variables (baseline patient characteristics)
               , age
               , sex
               , ethn
               , country
               , comed_dexa
               , comed_ab
               , comed_other
               , comorb_cat
               , sqsympdur
               , sqcrptrunc
               , vl_baseline
               , ae_28_sev
                 )
Y<-data.frame(clinstatus_n) # level 1 variable within clustering variable
X <- cbind(1, data.frame(clinicalstatus_baseline, time, timesq)) # matrix modelling linearity of clinstatus throughout day 28
clus<-data.frame(id_pat) # clustering variable (patient)
Z<-data.frame(rep(1,dim(df_imp_long_int)[1]),df_imp_long_int[,c("time")]) # random intercept and random slope
colnames(Z)<-c("const", "time") 

nimp<-30 # set number of iterations

## run jomo
# dry run
imputed_int_mcmc<-jomo.MCMCchain(Y=Y, Y2=Y2, X=X, Z=Z, clus=clus, nburn=2)
# plot(c(1:2),imputed_int_mcmc$collectbeta[1,1,1:2],type="l")
# plot(c(1:2),imputed_int_mcmc$collectcovu[5,5,1:2],type="l")
set.seed(1569)
imputed_int <- jomo(Y=Y, Y2=Y2, X=X, Z=Z, clus=clus, nburn=1000, nbetween=1000, nimp=nimp)
# nburn<-1000
# imputed_int_mcmc<-jomo.MCMCchain(Y=Y, Y2=Y2, X=X, Z=Z, clus=clus, nburn=nburn)
# plot(c(1:nburn),imputed_int_mcmc$collectbeta[1,1,1:nburn],type="l")
# plot(c(1:nburn),imputed_int_mcmc$collectcovu[5,5,1:nburn],type="l")

# convert to jomo object, split imputations, and exclude original data (imputation "0")
imp.list_int <- imputationList(split(imputed_int, imputed_int$Imputation)[-1])

# checks
round(prop.table(table(imp.list_int[[1]]$`1`$mort_28, useNA = "always"))*100,1) # first imputed dataset
round(prop.table(table(imp.list_int[[1]]$`2`$mort_28, useNA = "always"))*100,1) # second imputed dataset
round(prop.table(table(df_imp_long_int$mort_28, useNA = "always"))*100,1) # original data
summary(imp.list_int[[1]]$`1`$comorb_cat)
summary(imp.list_int[[1]]$`2`$sqsympdur)
summary(imp.list_int[[1]]$`2`$sqcrptrunc)


#### CONTROL group
## jomo only accepts numeric or factors, check and adapt
# str(df_imp_long_cont)
df_imp_long_cont$timesq <- sqrt(df_imp_long_cont$time) # see X below
df_imp_long_cont <- df_imp_long_cont %>% 
    mutate(clinicalstatus_baseline = case_when(is.na(clinicalstatus_baseline) ~ "5", # only for X below, see rules in Notes
                                             TRUE ~ clinicalstatus_baseline))
attach(df_imp_long_cont)
Y2<-data.frame(mort_28 # level 2 variables (baseline patient characteristics)
               , age
               , sex
               , ethn
               , country
               , comed_dexa
               , comed_ab
               , comed_other
               , comorb_cat
               , sqsympdur
               , sqcrptrunc
               , vl_baseline
               , ae_28_sev
                 )
Y<-data.frame(clinstatus_n) # level 1 variable within clustering variable
X <- cbind(1, data.frame(clinicalstatus_baseline, time, timesq)) # matrix modelling linearity of clinstatus throughout day 28
clus<-data.frame(id_pat) # clustering variable (patient)
Z<-data.frame(rep(1,dim(df_imp_long_cont)[1]),df_imp_long_cont[,c("time")]) # random intercept and random slope
colnames(Z)<-c("const", "time") 

nimp<-30 # set number of iterations

# run jomo
set.seed(1569)
imputed_cont <- jomo(Y=Y, Y2=Y2, X=X, Z=Z, clus=clus, nburn=1000, nbetween=1000, nimp=nimp)
# nburn<-1000
# imputed_cont_mcmc<-jomo.MCMCchain(Y=Y, Y2=Y2, X=X, Z=Z, clus=clus, nburn=nburn)
# plot(c(1:nburn),imputed_cont_mcmc$collectbeta[1,1,1:nburn],type="l")
# plot(c(1:nburn),imputed_cont_mcmc$collectcovu[5,5,1:nburn],type="l")

# convert to jomo object, split imputations, and exclude original data (imputation "0")
imp.list_cont <- imputationList(split(imputed_cont, imputed_cont$Imputation)[-1])

# checks
round(prop.table(table(imp.list_cont[[1]]$`1`$mort_28, useNA = "always"))*100,1) # first imputed dataset
round(prop.table(table(imp.list_cont[[1]]$`2`$mort_28, useNA = "always"))*100,1) # second imputed dataset
round(prop.table(table(df_imp_long_cont$mort_28, useNA = "always"))*100,1) # original data
summary(imp.list_cont[[1]]$`1`$comorb_cat)
summary(imp.list_cont[[1]]$`2`$sqsympdur)


#### Add trt back, change from long to wide format, and finally combine the two data frames
imputed_int$trt <- 1
imputed_int_s <- imputed_int %>% # remove imputation variables, not needed anymore
  select(trt, age, sex, ethn, country, comed_dexa, comed_ab, comed_other, comorb_cat, sqsympdur, sqcrptrunc, vl_baseline, ae_28_sev, mort_28, clinicalstatus_baseline, clus, Imputation)
imputed_int_wide <- imputed_int_s %>% # change from long to wide format, i.e. remove duplicates within Imputation sets
  group_by(Imputation) %>%
  distinct(clus, .keep_all = TRUE) 

imputed_cont$trt <- 0 # treatment variable
imputed_cont_s <- imputed_cont %>% # remove imputation variables, not needed anymore
  select(trt, age, sex, ethn, country, comed_dexa, comed_ab, comed_other, comorb_cat, sqsympdur, sqcrptrunc, vl_baseline, ae_28_sev, mort_28, clinicalstatus_baseline, clus, Imputation)
imputed_cont_wide <- imputed_cont_s %>% # change from long to wide format, i.e. remove duplicates within Imputation sets
  group_by(Imputation) %>%
  distinct(clus, .keep_all = TRUE) 

imputed_combined <- rbind(imputed_cont_wide, imputed_int_wide)


#### Convert combined df to jomo object, split imputations, and exclude original data (imputation "0")
imp.list <- imputationList(split(imputed_combined, imputed_combined$Imputation)[-1])


### Checks
round(prop.table(table(imp.list[[1]]$`1`$mort_28, imp.list[[1]]$`1`$trt, useNA = "always"),2)*100,1) # first imputed dataset
round(prop.table(table(imp.list[[1]]$`2`$mort_28, imp.list[[1]]$`2`$trt, useNA = "always"),2)*100,1) # second imputed dataset
round(prop.table(table(df_imp$mort_28, df_imp$trt, useNA = "always"),2)*100,1) # original data
summary(imp.list[[1]]$`1`$comorb_cat)
summary(imp.list[[1]]$`2`$sqsympdur)

```

# (i) Primary endpoint: Mortality at day 28
```{r warning=FALSE}
addmargins(table(df$mort_28, df$trt, useNA = "always"))
addmargins(table(df$mort_28_dimp, df$trt, useNA = "always"))
df$clinstatus_baseline_n <- as.numeric(df$clinstatus_baseline)

# Complete case analysis, substantive model
mort.28 <- df %>% 
  glm(mort_28 ~ trt 
      + age + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# Deterministic imputation
mort.28.dimp <- df %>% 
  glm(mort_28_dimp ~ trt 
      + age + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.dimp, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# Multiple imputation analysis under MAR; use mitools package to fit imputed and combined data list and apply Rubin's rules
# mort.28.mi <- imp.list %>%
#   with(glm(mort_28 ~ trt
#            + age
#            + clinicalstatus_baseline
#            , family = binomial)) %>%
#         pool() %>%
#         summary(conf.int = T, exponentiate = T)
# mort.28.mi

```

# (i.i) Covariate adjustment for primary endpoint: Mortality at day 28
```{r warning=FALSE}
# unadjusted estimator for the (absolute) risk difference
mort.28.prop.test <- prop.test(x = with(df, table(trt, mort_28)))
# print(mort.28.prop.test)
# Estimate
-diff(mort.28.prop.test$estimate)
# Confidence Interval
mort.28.prop.test$conf.int
# P-Value
mort.28.prop.test$p.value

# Covariate-Adjusted Analysis
# Fit the `glm` object
# Same as Complete case analysis, substantive model // but don't use piping, otherwise problem in margins::margins
df_mort28_comp <- df %>% filter(!is.na(mort_28))
mort.28.cov.adj <-
  glm(formula = mort_28 ~ trt + age + clinstatus_baseline,
      data = df_mort28_comp,
      family = binomial(link = "logit")
      )
# Print a summary of the `glm` object
summary(mort.28.cov.adj)
# Predict Pr{Y = 1 | Z = 1, X} // equals: E(Y|Z=1,X)
pr_y1_z1 <-
  predict(
    object = mort.28.cov.adj,
    newdata =
      df_mort28_comp %>%
      dplyr::mutate(
        trt = 1
      ),
    type = "response"
  )
# Predict Pr{Y = 1 | Z = 0, X} // equals: E(Y|Z=0,X)
pr_y1_z0 <-
  predict(
    object = mort.28.cov.adj,
    newdata =
      df_mort28_comp %>%
      dplyr::mutate(
        trt = 0
      ),
    type = "response"
  )

# Estimate RD
adj_mean = mean(pr_y1_z1) - mean(pr_y1_z0)
print(adj_mean)
# Standard Error RD
# The variance/standard error can be calculted as 1/n times the sample variance of:
# Z/P(Z=1)*[Y-E(Y|Z=1,X)] + E(Y|Z=1,X) - ((1-Z)/(1-P(1=Z))*[Y-E(Y|Z=0,X)] + E(Y|Z=0,X))
p_arm = mean(df_mort28_comp$trt==1)
adj_se = sqrt(
  var((df_mort28_comp$trt==1)/p_arm * (df_mort28_comp$mort_28 - pr_y1_z1) + pr_y1_z1 -
      ((df_mort28_comp$trt==0)/(1-p_arm) * (df_mort28_comp$mort_28-pr_y1_z0) + pr_y1_z0))/
    nrow(df_mort28_comp))
print(adj_se)
# Confidence Interval
c(adj_mean-qnorm(0.975)*adj_se, adj_mean+qnorm(0.975)*adj_se)

# Or, we can obtain the standard error of the estimate two ways. The first way is using the margins::margins() command, using the robust standard errors from sandwich::vcovHC // The second way to obtain these would be the bias corrected and accelerated (BCa) non-parametric bootstrap
# You’ll see that we now have a standard error, p-value under the hypothesis that the marginal effect is 0, and a 95% Confidence Interval for the estimate. 

library(sandwich)
library(margins)
mort.28.cov.adj.ame <-
  margins::margins(
    model = mort.28.cov.adj,
    # Specify treatment variable
    variables = "trt",
    # Convert to outcome scale, not link scale
    type = "response",
    # Obtain robust standard errors
    vcov = sandwich::vcovHC(x = mort.28.cov.adj, type = "HC3")
  )
summary(object = mort.28.cov.adj.ame, level = 0.95)
mort.28.ame <- summary(object = mort.28.cov.adj.ame, level = 0.95)
```

# (ii) Mortality at day 60
```{r warning=FALSE}
table(df$mort_60, df$trt, useNA = "always")
mort.60 <- df %>% 
  glm(mort_60 ~ trt 
      + age + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.60, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```

# (iii) Time to death within max. follow-up time
```{r warning=FALSE}
# table(df$death_reached, df$death_time, useNA = "always")
# table(df$death_reached, df$mort_60, useNA = "always")

# df %>%
#   drop_na(death_time) %>%
#   filter(death_reached == 1) %>%
#   group_by(trt) %>%
#   summarise(median = median(death_time),
#             IQR = IQR(death_time),
#             Q1 = quantile(death_time, probs = 0.25),
#             Q3 = quantile(death_time, probs = 0.75))

# time to death, by group. Kaplan-Meier estimate of conditional survival probability.
km.ttdeath.check <- with(df, Surv(death_time, death_reached))
# head(km.ttdeath.check, 100)

km.ttdeath_trt <- survfit(Surv(death_time, death_reached) ~ trt, data=df)
# summary(km.ttdeath_trt, times = 28)
ttdeath_28d_tbl <- km.ttdeath_trt %>% 
  tbl_survfit(
    times = 28,
    label_header = "**28-d survival (95% CI)**"
  )
# Nicely formatted table
kable(ttdeath_28d_tbl, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# autoplot(km.ttdeath_trt)
survfit2(Surv(death_time, death_reached) ~ trt, data=df) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall survival probability"
  ) + 
  add_confidence_interval() +
  add_risktable()

# testing: simple log-rank
# survdiff(Surv(death_time, death_reached) ~ trt, data = df)
# testing: cox ph
ttdeath <- df %>% 
  coxph(Surv(death_time, death_reached) ~ trt 
        + age + clinstatus_baseline
        , data =.)
ttdeath_reg_tbl <- tbl_regression(ttdeath, exp = TRUE)
# Nicely formatted table
kable(ttdeath_reg_tbl, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

# (iv) New mechanical ventilation among survivors within 28 days
```{r warning=FALSE}
addmargins(table(df$new_mv_28, df$trt, useNA = "always"))
new.mv.28 <- df %>% 
  glm(new_mv_28 ~ trt 
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(new.mv.28, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# (iv) Alternative definition/analysis: New mechanical ventilation OR death within 28 days => include all in denominator. 
addmargins(table(df$new_mvd_28, df$trt, useNA = "always"))
new.mvd.28 <- df %>% 
  glm(new_mvd_28 ~ trt 
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(new.mvd.28, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```

# (v) Clinical status at day 28
```{r warning=FALSE}
table(df$clinstatus_28_imp, df$trt, useNA = "always")
clin.28 <- df %>% 
  clm(clinstatus_28_imp ~ trt 
      + age 
      + clinstatus_baseline
      , link= c("logit"), data=.)
# Summary and extract coefficients
coefficients_table <- summary(clin.28)$coefficients
# Calculate Odds Ratios and Confidence Intervals
odds_ratios <- exp(coefficients_table[, "Estimate"])
ci_lower <- exp(coefficients_table[, "Estimate"] - 1.96 * coefficients_table[, "Std. Error"])
ci_upper <- exp(coefficients_table[, "Estimate"] + 1.96 * coefficients_table[, "Std. Error"])
# Create a data frame to store Odds Ratios and CIs
clin.28_tbl <- data.frame(
  "Variable" = rownames(coefficients_table),
  "Odds Ratio" = odds_ratios,
  "CI Lower" = ci_lower,
  "CI Upper" = ci_upper
)
# Nicely formatted table
kable(clin.28_tbl, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
```

# (vi) Time to discharge or reaching discharge criteria up to day 28
```{r warning=FALSE}
# Kaplan-Meier estimate of conditional discharge probability
# Censoring the deaths => Cause-specific hazards, i.e., represents the rate per unit of time of the event among those not having failed from other events. Instantaneous rate of occurrence of the given type of event in subjects who are currently event‐free. But by simply censoring the competing event, we bias in favour of comparator (if treatment leads to less deaths)
km.ttdischarge.check <- with(df, Surv(discharge_time, discharge_reached))
# head(km.ttdischarge.check, 100)
km.ttdischarge_trt <- survfit(Surv(discharge_time, discharge_reached) ~ trt, data=df)
# summary(km.ttdischarge_trt, times = 28)
ttdischarge_28d_tbl <- km.ttdischarge_trt %>% 
  tbl_survfit(
    times = 28,
    label_header = "**28-d hospitalization (95% CI)**"
  )
# Nicely formatted table
kable(ttdischarge_28d_tbl, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)
survfit2(Surv(discharge_time, discharge_reached) ~ trt, data=df) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall hospitalization probability"
  ) + 
  add_confidence_interval() +
  add_risktable()
# testing: cox ph
ttdischarge <- df %>% 
  coxph(Surv(discharge_time, discharge_reached) ~ trt 
        + age + clinstatus_baseline
        , data =.)
ttdischarge_reg_tbl <- tbl_regression(ttdischarge, exp = TRUE)
# Nicely formatted table
kable(ttdischarge_reg_tbl, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Sub-distribution hazards, i.e., represents the rate per unit of time of the event as well as the influence of competing events. Instantaneous rate of occurrence of the given type of event in subjects who have not yet experienced an event of that type.
df <- df %>% # cuminc needs a factor variable with censored patients coded as 0, the event as 1 and the competing event as 2.
  mutate(discharge_reached_comp = case_when (discharge_reached == 0 & (mort_28 == 0 | is.na(mort_28)) ~ 0,
                                             discharge_reached == 1 & (mort_28 == 0 | is.na(mort_28)) ~ 1,
                                             mort_28 == 1 ~ 2))

df$discharge_reached_comp <- as.factor(df$discharge_reached_comp) 
# table(df$discharge_reached_comp)
# table(df$discharge_reached_comp, df$discharge_time)
# table(df$discharge_reached, df$discharge_time)

# Cumulative incidence for the event=discharge (1) and the competing event=death (2)
cuminc(Surv(discharge_time, discharge_reached_comp) ~ 1, data = df)
cuminc(Surv(discharge_time, discharge_reached_comp) ~ trt, data = df) %>% 
  ggcuminc(outcome = c("1", "2")) +
  ylim(c(0, 1)) + 
  labs(
    x = "Days"
  ) + 
  add_confidence_interval() +
  add_risktable()
# in int only
df_int <- df %>% 
  filter(trt == 1)
cuminc(Surv(discharge_time, discharge_reached_comp) ~ trt, data = df_int) %>% 
  ggcuminc(outcome = c("1", "2")) +
  #ylim(c(0, 1)) + 
  labs(
    x = "Days"
  ) + 
  add_confidence_interval() +
  add_risktable()
# in cont only
df_cont <- df %>% 
  filter(trt == 0)
cuminc(Surv(discharge_time, discharge_reached_comp) ~ trt, data = df_cont) %>% 
  ggcuminc(outcome = c("1", "2")) +
  #ylim(c(0, 1)) + 
  labs(
    x = "Days"
  ) + 
  add_confidence_interval() +
  add_risktable()

# testing: Fine-Gray regression
ttdischarge.comp <- crr(Surv(discharge_time, discharge_reached_comp) ~ trt 
    + age 
    #+ clinstatus_baseline
    ,data = df)
ttdischarge_comp_reg_tbl <- tbl_regression(ttdischarge.comp, exp = TRUE)
# Nicely formatted table
kable(ttdischarge_comp_reg_tbl, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Censoring and assigned worst outcome (28d) to competing event (death) // hypothetical estimand where no-one died. (Another option could be, but we don't do it, is to exclude the deaths entirely, i.e. discharge among those that survived (but that might bias in favour of those in control that died more, i.e. healthier comparator))
survfit2(Surv(discharge_time_sens, discharge_reached) ~ trt, data=df) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall hospitalization probability"
  ) + 
  add_confidence_interval() +
  add_risktable()
# testing: cox ph
ttdischarge.sens <- df %>% 
  coxph(Surv(discharge_time_sens, discharge_reached) ~ trt 
        + age + clinstatus_baseline
        , data =.)
ttdischarge_sens_reg_tbl <- tbl_regression(ttdischarge.sens, exp = TRUE)
# Nicely formatted table
kable(ttdischarge_sens_reg_tbl, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Sens-analysis: Alternative definition/analysis of outcome: time to sustained discharge within 28 days
# Use cause-specific hazards
survfit2(Surv(discharge_time_sus, discharge_reached_sus) ~ trt, data=df) %>% 
  ggsurvfit() +
  labs(
    x = "Days",
    y = "Overall sustained hospitalization probability"
  ) + 
  add_confidence_interval() +
  add_risktable()
# testing: cox ph
ttdischarge.sus <- df %>% 
  coxph(Surv(discharge_time_sus, discharge_reached_sus) ~ trt 
        + age + clinstatus_baseline
        , data =.)
ttdischarge_sus_reg_tbl <- tbl_regression(ttdischarge.sus, exp = TRUE)
# Nicely formatted table
kable(ttdischarge_sus_reg_tbl, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

```
Discussion points
1. Use F&G for sens-analysis (sustained discharge)?

# (vii) Viral clearance up to day 5, day 10, and day 15
```{r warning=FALSE}
table(df$vir_clear_5, df$trt, useNA = "always") #  (Viral load value <LOQ and/or undectectable)
# up to 5 days
vir.clear.5 <- df %>% 
  glm(vir_clear_5 ~ trt 
      + age + clinstatus_baseline
      , family = "binomial", data=.)
summ(vir.clear.5, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# up to 10 days
table(df$vir_clear_10, df$trt, useNA = "always") #  (Viral load value <LOQ and/or undectectable)
vir.clear.10 <- df %>% 
  glm(vir_clear_10 ~ trt 
      + age + clinstatus_baseline
      , family = "binomial", data=.)
summ(vir.clear.10, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# up to 15 days
table(df$vir_clear_15, df$trt, useNA = "always") #  (Viral load value <LOQ and/or undectectable)
vir.clear.15 <- df %>% 
  glm(vir_clear_15 ~ trt 
      + age + clinstatus_baseline
      , family = "binomial", data=.)
summ(vir.clear.15, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```

# (viii) Quality of life at day 28 
```{r warning=FALSE}

```
Discussion points
1. Not available in COV-BARRIER

# (ix) Adverse event(s) grade 3 or 4, or a serious adverse event(s), excluding death, by day 28
```{r warning=FALSE}
table(df$ae_28, df$trt, useNA = "always")
ae.28 <- df %>% 
  glm(ae_28 ~ trt 
      + age + clinstatus_baseline
      , family = "binomial", data=.)
summ(ae.28, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# (ix) Sens-analysis: Alternative definition/analysis of outcome: incidence rate ratio (Poisson regression) -> AE per person by d28
table(df$ae_28_sev, df$trt, useNA = "always")
ae.28.sev <- df %>% 
  glm(ae_28_sev ~ trt 
      + age + clinstatus_baseline
      , family = "poisson", data=.)
summ(ae.28.sev, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```

# Subgroup analysis: Ventilation requirement (proxy for disease severity) on primary endpoint
```{r warning=FALSE}
table(df$clinstatus_baseline, df$mort_28, useNA = "always")
table(df$vbaseline, df$mort_28, useNA = "always")
df$clinstatus_baseline_n <- as.numeric(df$clinstatus_baseline)

mort.28.vent <- df %>% 
  glm(mort_28 ~ trt*clinstatus_baseline_n
      + age 
      #+ clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.vent, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
mort.28.vent.vb <- df %>% 
  glm(mort_28 ~ trt*vbaseline
      + age 
     # + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.vent.vb, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# effect by subgroup
mort.28.vent.vb.yes <- df %>% 
  filter(vbaseline == 1) %>% # ventilated
  glm(mort_28 ~ trt
      + age 
     # + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.vent.vb.yes, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

mort.28.vent.vb.no <- df %>% 
  filter(vbaseline == 0) %>% # not ventilated
  glm(mort_28 ~ trt
      + age 
     # + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.vent.vb.no, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# class(df$clinstatus_baseline)
mort.28.vent.rs.2 <- df %>% 
  filter(clinstatus_baseline == "2") %>% # no oxygen
  glm(mort_28 ~ trt
      + age 
     # + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.vent.rs.2, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
mort.28.vent.rs.3 <- df %>% 
  filter(clinstatus_baseline == "3") %>% # LF oxygen
  glm(mort_28 ~ trt
      + age 
     # + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.vent.rs.3, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
mort.28.vent.rs.4 <- df %>% 
  filter(clinstatus_baseline == "4") %>% # HF oxygen/NIV
  glm(mort_28 ~ trt
      + age 
     # + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.vent.rs.4, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
mort.28.vent.rs.5 <- df %>% 
  filter(clinstatus_baseline == "5") %>% # ECMO
  glm(mort_28 ~ trt
      + age 
     # + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.vent.rs.5, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```

# Subgroup analysis: Age on primary endpoint
```{r warning=FALSE}
# table(df$age, df$mort_28, useNA = "always")
mort.28.age <- df %>% 
  glm(mort_28 ~ trt*age
      #+ age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.age, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# effect by subgroup
df <- df %>% 
  mutate(age_70 = case_when(age < 70 ~ 0,
                            age > 69 ~ 1))
table(df$age_70, useNA = "always")
mort.28.age.a70 <- df %>% 
  filter(age_70 == 1) %>% # 70 and above
  glm(mort_28 ~ trt
      # + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.age.a70, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

mort.28.age.b70 <- df %>% 
  filter(age_70 == 0) %>% # below 70
  glm(mort_28 ~ trt
      # + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.age.b70, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```

# Subgroup analysis: Comorbidities on primary endpoint
```{r warning=FALSE}
# 4 comorbidity categories as numeric/continuous, i.e., linear interaction
table(df$comorb_cat, df$mort_28, useNA = "always") 
# class(df$comorb_cat)
mort.28.comorb <- df %>%
  glm(mort_28 ~ trt*comorb_cat 
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comorb, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
# 4 comorbidity categories as factor
df$comorb_cat_f <- as.factor(df$comorb_cat)
# table(df$comorb_cat_f, df$mort_28, useNA = "always") 
mort.28.comorb.f <- df %>% 
  glm(mort_28 ~ trt*comorb_cat_f 
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comorb.f, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
# full comorbidity count
# table(df$comorb_count, df$mort_28, useNA = "always") 
mort.28.comorb.count <- df %>%
  glm(mort_28 ~ trt*comorb_count 
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comorb.count, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
# any comorbidity
# table(df$comorb_any, df$mort_28, useNA = "always") 
mort.28.comorb.any <- df %>%
  glm(mort_28 ~ trt*comorb_any 
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comorb.any, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
# comorbidities without immunosuppressed
# table(df$comorb_cat, df$mort_28, useNA = "always")
df <- df %>% 
  mutate(comorb_noimmuno = case_when(comorb_cat == 4 ~ NA,
                              TRUE ~ comorb_cat))
# table(df$comorb_noimmuno, df$mort_28, useNA = "always")
mort.28.comorb.noimmuno <- df %>%
  glm(mort_28 ~ trt*comorb_noimmuno 
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comorb.noimmuno, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# effect by subgroup
mort.28.comorb.1 <- df %>% 
  filter(comorb_cat == 1) %>% # no comorbidity
  glm(mort_28 ~ trt
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comorb.1, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

mort.28.comorb.2 <- df %>% 
  filter(comorb_cat == 2) %>% # 1 comorbidity
  glm(mort_28 ~ trt
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comorb.2, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

mort.28.comorb.3 <- df %>% 
  filter(comorb_cat == 3) %>% # multiple comorbidities
  glm(mort_28 ~ trt
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comorb.3, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

mort.28.comorb.4 <- df %>% 
  filter(comorb_cat == 4) %>% # immunocompromised
  logistf(mort_28 ~ trt
      + age 
      + clinstatus_baseline
      , data=.)
summary(mort.28.comorb.4)

```

# Subgroup analysis: Concomitant COVID-19 treatment on primary endpoint
```{r warning=FALSE}
# 4 comorbidity categories as numeric/continuous, i.e., linear interaction
table(df$comed_cat, df$trt, useNA = "always")
# 1: patients without Dexamethasone nor Tocilizumab => JAKi effect alone
# 2: patients with Dexamethasone but no Tocilizumab => JAKi effect with Dexa only
# 3: patients with Dexamethasone and Tocilizumab => JAKi effect with Dexa + Toci
# 4: patients with Tocilizumab but no Dexamethasone (if exist) => JAKi effect with Toci only 
mort.28.comed <- df %>%
  glm(mort_28 ~ trt*comed_cat 
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comed, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
# comedication as ordinal factor
df$comed_cat_f <- factor(df$comed_cat, levels = 1:4)
# table(df$comed_cat_f, df$mort_28, useNA = "always") 
mort.28.comed.f <- df %>%
  glm(mort_28 ~ trt*comed_cat_f 
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comed.f, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# effect by subgroup
mort.28.comed.1 <- df %>% 
  filter(comed_cat == 1) %>% # without Dexamethasone nor Tocilizumab
  glm(mort_28 ~ trt
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comed.1, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

mort.28.comed.2 <- df %>% 
  filter(comed_cat == 2) %>% # Dexamethasone but no Tocilizumab
  glm(mort_28 ~ trt
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.comed.2, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```

# Subgroup analysis: Vaccination on adverse events
```{r warning=FALSE}
# table(df$vacc, df$trt, useNA = "always")
# ae.28.vacc <- df %>% 
#   glm(ae_28 ~ trt*vacc
#       + age 
#       #+ clinstatus_baseline 
#       #+ comed_dexa + comed_rdv + comed_toci
#       , family = "binomial", data=.)
# summ(ae.28.vacc, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```
Discussion points
1. Vacc not available in COV-BARRIER

# SENS Subgroup analysis: Duration since symptom onset on primary endpoint
```{r warning=FALSE}
# table(df$sympdur, df$mort_28, useNA = "always")
mort.28.symp <- df %>% 
  glm(mort_28 ~ trt*sympdur
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.symp, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# effect by subgroup
df <- df %>% 
  mutate(sympdur_cat = case_when(sympdur < 6 ~ 2,
                                 sympdur > 5 & sympdur < 11 ~ 1,
                                 sympdur > 10 ~ 0))
# table(df$sympdur_cat, useNA = "always")
# table(df$sympdur, useNA = "always")
mort.28.sympdur.a10 <- df %>% 
  filter(sympdur_cat == 0) %>% # more than 10 days
  glm(mort_28 ~ trt
      + age 
      + clinstatus_baseline 
      , family = "binomial", data=.)
summ(mort.28.sympdur.a10, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

mort.28.sympdur.510 <- df %>% 
  filter(sympdur_cat == 1) %>% # 5-10 days
  glm(mort_28 ~ trt
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.sympdur.510, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

mort.28.sympdur.b5 <- df %>% 
  filter(sympdur_cat == 2) %>% # 5d or less
  glm(mort_28 ~ trt
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.sympdur.b5, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```

# SENS Subgroup analysis: CRP on primary endpoint
```{r warning=FALSE}
# table(df$crp, df$mort_28, useNA = "always")
mort.28.crp <- df %>% 
  glm(mort_28 ~ trt*crp
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.crp, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# # truncate outliers > 500
# df <- df %>% 
#   mutate(crp_trunc = case_when(crp > 500 ~ 500,
#                                TRUE ~ crp))
# mort.28.crp.trunc <- df %>% 
#   glm(mort_28 ~ trt*crp_trunc
#       + age 
#       + clinstatus_baseline
#       , family = "binomial", data=.)
# summ(mort.28.crp.trunc, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

# effect by subgroup
df <- df %>% 
  mutate(crp_75 = case_when(crp < 75 ~ 1,
                            crp > 74 ~ 0))
# table(df$crp_75, useNA = "always")
mort.28.crp.b75 <- df %>% 
  filter(crp_75 == 1) %>% # below 75
  glm(mort_28 ~ trt
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.crp.b75, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)

mort.28.crp.a75 <- df %>% 
  filter(crp_75 == 0) %>% # 75 and above
  glm(mort_28 ~ trt
      + age 
      + clinstatus_baseline
      , family = "binomial", data=.)
summ(mort.28.crp.a75, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```

# SENS Subgroup analysis: Variant on primary endpoint
```{r warning=FALSE}
# # table(df$variant, df$mort_28, useNA = "always")
# mort.28.var <- df %>% 
#   glm(mort_28 ~ trt*variant
#       + age 
#       + clinstatus_baseline 
#       #+ comed_dexa + comed_rdv + comed_toci
#       , family = "binomial", data=.)
# summ(mort.28.var, exp = T, confint = T, model.info = T, model.fit = F, digits = 2)
```
Discussion points
1. variant not available

# Collect all treatment effect estimates across endpoints (stage one)
```{r message=FALSE, warning=FALSE}
# Empty data frame to store the results
result_df <- data.frame(
  variable = character(),
  hazard_odds_ratio = numeric(),
  ci_lower = numeric(),
  ci_upper = numeric(),
  standard_error = numeric(),
  p_value = numeric(),
  n_int = numeric(),
  n_cont = numeric(),
  e_int = numeric(),
  e_cont = numeric()
)

# Function to extract treatment results from different model types (glm, clm, coxph and crr)
extract_trt_results <- function(model, variable_name, n_int, n_cont, e_int, e_cont) {
  if (inherits(model, "glm") || inherits(model, "clm")) {
    trt_coef <- coef(model)["trt"]
    hazard_odds_ratio <- exp(trt_coef)
    ci <- exp(confint(model)["trt", ])
    se <- summary(model)$coefficients["trt", "Std. Error"]
    p_value <- summary(model)$coefficients["trt", "Pr(>|z|)"]
  } else if (inherits(model, "coxph")) {
    trt_coef <- coef(model)["trt"]
    hazard_odds_ratio <- exp(trt_coef)
    ci <- exp(confint(model)["trt", ])
    se <- summary(model)$coefficients["trt", "se(coef)"]
    p_value <- summary(model)$coefficients["trt", "Pr(>|z|)"]
  } else if (inherits(model, "tidycrr")) {
    trt_coef <- coef(model)["trt"]
    hazard_odds_ratio <- exp(trt_coef)
    ci <- c(exp(model$tidy$conf.low[1]), exp(model$tidy$conf.high[1]))
    se <- model$tidy$std.error[1]
    p_value <- model$tidy$p.value[1]
  } else if (inherits(model, "summary.margins")) {
    hazard_odds_ratio <- model$AME ### CAVE: this is not an HR or OR, but a marginal RD
    ci <- c(model$lower, model$upper)
    se <- model$SE
    p_value <- model$p
  } else if (inherits(model, "data.frame")) {
    hazard_odds_ratio <- model$estimate[2]
    ci <- c(model$`2.5 %`[2], model$`97.5 %`[2])
    se <- model$std.error[2]
    p_value <- model$p.value[2]
  } else {
    stop("Unsupported model class")
  }
  # capture the results
  result <- data.frame(
    variable = variable_name,
    hazard_odds_ratio = hazard_odds_ratio,
    ci_lower = ci[1],
    ci_upper = ci[2],
    standard_error = se,
    p_value = p_value,
    n_int = n_int,
    n_cont = n_cont,
    e_int = e_int,
    e_cont = e_cont
  )
  return(result)
}

# Loop through
result_list <- list()

result_list[[1]] <- extract_trt_results(mort.28, "death at day 28",
                                        addmargins(table(df$mort_28, df$trt))[3,2], 
                                        addmargins(table(df$mort_28, df$trt))[3,1],
                                        addmargins(table(df$mort_28, df$trt))[2,2],
                                        addmargins(table(df$mort_28, df$trt))[2,1])
result_list[[2]] <- extract_trt_results(mort.28.dimp, "death at day 28_dimp",
                                        addmargins(table(df$mort_28_dimp, df$trt))[3,2], 
                                        addmargins(table(df$mort_28_dimp, df$trt))[3,1],
                                        addmargins(table(df$mort_28_dimp, df$trt))[2,2], 
                                        addmargins(table(df$mort_28_dimp, df$trt))[2,1])
# result_list[[3]] <- extract_trt_results(mort.28.mi, "death at day 28_mi",
#                                         addmargins(table(df$mort_28, df$trt))[3,2], 
#                                         addmargins(table(df$mort_28, df$trt))[3,1],
#                                         addmargins(table(df$mort_28, df$trt))[2,2], 
#                                         addmargins(table(df$mort_28, df$trt))[2,1]) 
result_list[[4]] <- extract_trt_results(mort.28.ame, "death at day 28_marginal",
                                        addmargins(table(df$mort_28, df$trt))[3,2], 
                                        addmargins(table(df$mort_28, df$trt))[3,1],
                                        addmargins(table(df$mort_28, df$trt))[2,2], 
                                        addmargins(table(df$mort_28, df$trt))[2,1])
result_list[[5]] <- extract_trt_results(mort.60, "death at day 60",
                                        addmargins(table(df$mort_60, df$trt))[3,2], 
                                        addmargins(table(df$mort_60, df$trt))[3,1],
                                        addmargins(table(df$mort_60, df$trt))[2,2], 
                                        addmargins(table(df$mort_60, df$trt))[2,1])
result_list[[6]] <- extract_trt_results(ttdeath, "death within fup",
                                        addmargins(table(df$death_reached, df$trt))[3,2], 
                                        addmargins(table(df$death_reached, df$trt))[3,1],
                                        addmargins(table(df$death_reached, df$trt))[2,2], 
                                        addmargins(table(df$death_reached, df$trt))[2,1])
result_list[[7]] <- extract_trt_results(new.mv.28, "new MV within 28d",
                                        addmargins(table(df$new_mv_28, df$trt))[3,2], 
                                        addmargins(table(df$new_mv_28, df$trt))[3,1],
                                        addmargins(table(df$new_mv_28, df$trt))[2,2], 
                                        addmargins(table(df$new_mv_28, df$trt))[2,1])
result_list[[8]] <- extract_trt_results(new.mvd.28, "new MV or death within 28d",
                                        addmargins(table(df$new_mvd_28, df$trt))[3,2], 
                                        addmargins(table(df$new_mvd_28, df$trt))[3,1],
                                        addmargins(table(df$new_mvd_28, df$trt))[2,2], 
                                        addmargins(table(df$new_mvd_28, df$trt))[2,1])
result_list[[9]] <- extract_trt_results(clin.28, "clinical status at day 28",
                                        addmargins(table(df$clinstatus_28_imp, df$trt))[7,2], 
                                        addmargins(table(df$clinstatus_28_imp, df$trt))[7,1],
                                        NA,
                                        NA)
result_list[[10]] <- extract_trt_results(ttdischarge, "discharge within 28 days",
                                        addmargins(table(df$discharge_reached, df$trt))[3,2], 
                                        addmargins(table(df$discharge_reached, df$trt))[3,1],
                                        addmargins(table(df$discharge_reached, df$trt))[2,2], 
                                        addmargins(table(df$discharge_reached, df$trt))[2,1])
result_list[[11]] <- extract_trt_results(ttdischarge.comp, "discharge within 28 days, death=comp.event",
                                        addmargins(table(df$discharge_reached, df$trt))[3,2], 
                                        addmargins(table(df$discharge_reached, df$trt))[3,1],
                                        addmargins(table(df$discharge_reached, df$trt))[2,2], 
                                        addmargins(table(df$discharge_reached, df$trt))[2,1])
result_list[[12]] <- extract_trt_results(ttdischarge.sens, "discharge within 28 days, death=hypo.event",
                                        addmargins(table(df$discharge_reached, df$trt))[3,2], 
                                        addmargins(table(df$discharge_reached, df$trt))[3,1],
                                        addmargins(table(df$discharge_reached, df$trt))[2,2], 
                                        addmargins(table(df$discharge_reached, df$trt))[2,1])
result_list[[13]] <- extract_trt_results(ttdischarge.sus, "sustained discharge within 28 days",
                                         addmargins(table(df$discharge_reached_sus, df$trt))[3,2], 
                                         addmargins(table(df$discharge_reached_sus, df$trt))[3,1],
                                         addmargins(table(df$discharge_reached_sus, df$trt))[2,2], 
                                         addmargins(table(df$discharge_reached_sus, df$trt))[2,1])
result_list[[14]] <- extract_trt_results(vir.clear.5, "viral clearance until day 5",
                                        addmargins(table(df$vir_clear_5, df$trt))[3,2], 
                                        addmargins(table(df$vir_clear_5, df$trt))[3,1],
                                        addmargins(table(df$vir_clear_5, df$trt))[2,2], 
                                        addmargins(table(df$vir_clear_5, df$trt))[2,1]) 
result_list[[15]] <- extract_trt_results(vir.clear.10, "viral clearance until day 10",
                                        addmargins(table(df$vir_clear_10, df$trt))[3,2], 
                                        addmargins(table(df$vir_clear_10, df$trt))[3,1],
                                        addmargins(table(df$vir_clear_10, df$trt))[2,2], 
                                        addmargins(table(df$vir_clear_10, df$trt))[2,1])
result_list[[16]] <- extract_trt_results(vir.clear.15, "viral clearance until day 15",
                                        addmargins(table(df$vir_clear_15, df$trt))[3,2], 
                                        addmargins(table(df$vir_clear_15, df$trt))[3,1],
                                        addmargins(table(df$vir_clear_15, df$trt))[2,2], 
                                        addmargins(table(df$vir_clear_15, df$trt))[2,1])
result_list[[17]] <- extract_trt_results(ae.28, "Any AE grade 3,4 within 28 days",
                                         addmargins(table(df$ae_28, df$trt))[3,2], 
                                         addmargins(table(df$ae_28, df$trt))[3,1],
                                         addmargins(table(df$ae_28, df$trt))[2,2], 
                                         addmargins(table(df$ae_28, df$trt))[2,1])
result_list[[18]] <- extract_trt_results(ae.28.sev, "AEs grade 3,4 within 28 days",
                                         addmargins(table(df$ae_28_sev, df$trt))[13,2], 
                                         addmargins(table(df$ae_28_sev, df$trt))[13,1],
                                         NA,
                                         NA)

# Filter out NULL results and bind the results into a single data frame
result_df <- do.call(rbind, Filter(function(x) !is.null(x), result_list))

# Add the trial name and JAKi
result_df$trial <- "COV-BARRIER"
result_df$JAKi <- "Baricitinib"

# Nicely formatted table
kable(result_df, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Save
saveRDS(result_df, file = "trt_effects_cov-barrier.RData")
```

# Collect all interaction estimates (stage one)
```{r message=FALSE, warning=FALSE}
# Empty data frame to store the results
interaction_df <- data.frame(
  variable = character(),
  log_odds_ratio = numeric(),
  ci_lower = numeric(),
  ci_upper = numeric(),
  standard_error = numeric(),
  p_value = numeric()
)
# Extract and format results for the interaction term
extract_interaction <- function(model, variable_name) {
  if (inherits(model, "glm") || inherits(model, "clm")) {
      trt_coef <- coef(model)[grep("^trt:", names(coef(model)))]
      log_odds_ratio <- exp(trt_coef)
      ci <- exp(confint(model)[grep("^trt:", names(coef(model))), ])
      se <- summary(model)$coefficients[grep("^trt:", names(coef(model))), "Std. Error"]
      p_value <- summary(model)$coefficients[grep("^trt:", names(coef(model))), "Pr(>|z|)"]
  } else if (inherits(model, "logistf")) {
      trt_coef <- coef(model)[grep("^trt:", names(coef(model)))]
      log_odds_ratio <- exp(trt_coef)
      ci <- exp(confint(model)[grep("^trt:", names(coef(model))), ])
      se <- sqrt(diag(vcov(model)))[grep("^trt:", names(coef(model)))]
      p_value <- model$prob[grep("^trt:", names(coef(model)))]
  } else {
    stop("Unsupported model class")
  }
      # capture the results
      result <- data.frame(
        variable = variable_name,
        log_odds_ratio = log_odds_ratio,
        ci_lower = ci[1],
        ci_upper = ci[2],
        standard_error = se,
        p_value = p_value
      )
    return(result)
}
# Loop through
result_list <- list()

result_list[[1]] <- extract_interaction(mort.28.vent, "respiratory support") # adj: age, clinstatus
result_list[[2]] <- extract_interaction(mort.28.vent.vb, "ventilation") # adj: age, clinstatus
result_list[[3]] <- extract_interaction(mort.28.age, "age") # adj: age, clinstatus
result_list[[4]] <- extract_interaction(mort.28.comorb, "comorbidity") # adj: age, clinstatus
result_list[[5]] <- extract_interaction(mort.28.comorb.count, "comorbidity_count") # adj: age, clinstatus
result_list[[6]] <- extract_interaction(mort.28.comorb.any, "comorbidity_any") # adj: age, clinstatus 
result_list[[7]] <- extract_interaction(mort.28.comorb.noimmuno, "comorbidity_noimmuno") # adj: age, clinstatus 
result_list[[8]] <- extract_interaction(mort.28.comed, "comedication") # adj: age, clinstatus
# result_list[[9]] <- extract_interaction(ae.28.vacc, "vaccination on AEs") # vacc not available
result_list[[10]] <- extract_interaction(mort.28.symp, "symptom duration") # adj: age, clinstatus
result_list[[11]] <- extract_interaction(mort.28.crp, "crp") # adj: age, clinstatus
# result_list[[12]] <- extract_interaction(mort.28.var, "variant") # variant not available

# Filter out NULL results and bind the results into a single data frame
interaction_df <- do.call(rbind, Filter(function(x) !is.null(x), result_list))

# Add the trial name and JAKi
interaction_df$trial <- "COV-BARRIER"
interaction_df$JAKi <- "Baricitinib"

# Nicely formatted table
kable(interaction_df, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Save
saveRDS(interaction_df, file = "int_effects_cov-barrier.RData")
```

# Collect all subgroup treatment effect estimates
```{r message=FALSE, warning=FALSE}
# Empty data frame to store the results
subgroup_df <- data.frame(
  variable = character(),
  hazard_odds_ratio = numeric(),
  ci_lower = numeric(),
  ci_upper = numeric(),
  standard_error = numeric(),
  p_value = numeric(),
  n_intervention = numeric(),
  n_intervention_tot = numeric(),
  n_control = numeric(),
  n_control_tot = numeric()
)

# Function to extract subgroup treatment results
extract_subgroup_results <- function(model, variable_name, n_int, n_int_tot, n_cont, n_cont_tot) {
  if (inherits(model, "glm")) {
    trt_coef <- coef(model)["trt"]
    hazard_odds_ratio <- exp(trt_coef)
    ci <- exp(confint(model)["trt", ])
    se <- summary(model)$coefficients["trt", "Std. Error"]
    p_value <- summary(model)$coefficients["trt", "Pr(>|z|)"]
  } else if (inherits(model, "logistf")) {
    trt_coef <- coef(model)[grep("^trt", names(coef(model)))]
    hazard_odds_ratio <- exp(trt_coef)
    ci <- exp(confint(model)[grep("^trt", names(coef(model))), ])
    se <- sqrt(diag(vcov(model)))[grep("^trt", names(coef(model)))]
    p_value <- model$prob[grep("^trt", names(coef(model)))]
  } else {
    stop("Unsupported model class")
  }
  # capture the results
  result <- data.frame(
    variable = variable_name,
    hazard_odds_ratio = hazard_odds_ratio,
    ci_lower = ci[1],
    ci_upper = ci[2],
    standard_error = se,
    p_value = p_value,
    n_intervention = n_int,
    n_intervention_tot = n_int_tot,
    n_control = n_cont,
    n_control_tot = n_cont_tot
  )
  return(result)
}

# Loop through
result_list <- list()

result_list[[1]] <- extract_subgroup_results(mort.28.vent.vb.yes, "High-flow or non-invasive, mechanical, or ECMO",
                                             addmargins(table(df$vbaseline, df$mort_28, df$trt))[2,2,2], 
                                             addmargins(table(df$vbaseline, df$mort_28, df$trt))[2,3,2], 
                                             addmargins(table(df$vbaseline, df$mort_28, df$trt))[2,2,1], 
                                             addmargins(table(df$vbaseline, df$mort_28, df$trt))[2,3,1]) 
result_list[[2]] <- extract_subgroup_results(mort.28.vent.vb.no, "None or low-flow oxygen",
                                             addmargins(table(df$vbaseline, df$mort_28, df$trt))[1,2,2], 
                                             addmargins(table(df$vbaseline, df$mort_28, df$trt))[1,3,2], 
                                             addmargins(table(df$vbaseline, df$mort_28, df$trt))[1,2,1], 
                                             addmargins(table(df$vbaseline, df$mort_28, df$trt))[1,3,1]) 
result_list[[3]] <- extract_subgroup_results(mort.28.vent.rs.2, "No oxygen",
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[2,2,2], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[2,3,2], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[2,2,1], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[2,3,1])
result_list[[4]] <- extract_subgroup_results(mort.28.vent.rs.3, "low-flow oxygen",
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[3,2,2], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[3,3,2], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[3,2,1], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[3,3,1])
result_list[[5]] <- extract_subgroup_results(mort.28.vent.rs.4, "high-flow oxygen / NIV",
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[4,2,2], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[4,3,2], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[4,2,1], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[4,3,1])
result_list[[6]] <- extract_subgroup_results(mort.28.vent.rs.5, "Mechanical ventilation / ECMO",
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[5,2,2], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[5,3,2], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[5,2,1], 
                                             addmargins(table(df$clinstatus_baseline, df$mort_28, df$trt))[5,3,1]) 
result_list[[7]] <- extract_subgroup_results(mort.28.age.a70, "70 years and above",
                                             addmargins(table(df$age_70, df$mort_28, df$trt))[2,2,2], 
                                             addmargins(table(df$age_70, df$mort_28, df$trt))[2,3,2], 
                                             addmargins(table(df$age_70, df$mort_28, df$trt))[2,2,1], 
                                             addmargins(table(df$age_70, df$mort_28, df$trt))[2,3,1]) 
result_list[[8]] <- extract_subgroup_results(mort.28.age.b70, "below 70 years",
                                             addmargins(table(df$age_70, df$mort_28, df$trt))[1,2,2], 
                                             addmargins(table(df$age_70, df$mort_28, df$trt))[1,3,2], 
                                             addmargins(table(df$age_70, df$mort_28, df$trt))[1,2,1], 
                                             addmargins(table(df$age_70, df$mort_28, df$trt))[1,3,1]) 
result_list[[9]] <- extract_subgroup_results(mort.28.comorb.1, "No comorbidity",
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[1,2,2], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[1,3,2], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[1,2,1], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[1,3,1])
result_list[[10]] <- extract_subgroup_results(mort.28.comorb.2, "One comorbidity",
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[2,2,2], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[2,3,2], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[2,2,1], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[2,3,1])
result_list[[11]] <- extract_subgroup_results(mort.28.comorb.3, "Multiple comorbidities",
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[3,2,2], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[3,3,2], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[3,2,1], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[3,3,1])
result_list[[12]] <- extract_subgroup_results(mort.28.comorb.4, "Immunocompromised_firth",
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[4,2,2], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[4,3,2], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[4,2,1], 
                                             addmargins(table(df$comorb_cat_f, df$mort_28, df$trt))[4,3,1]) 
result_list[[13]] <- extract_subgroup_results(mort.28.comed.1, "No Dexa, no Tocilizumab",
                                             addmargins(table(df$comed_cat, df$mort_28, df$trt))[1,2,2],
                                             addmargins(table(df$comed_cat, df$mort_28, df$trt))[1,3,2],
                                             addmargins(table(df$comed_cat, df$mort_28, df$trt))[1,2,1],
                                             addmargins(table(df$comed_cat, df$mort_28, df$trt))[1,3,1])
result_list[[14]] <- extract_subgroup_results(mort.28.comed.2, "Dexa, but no Tocilizumab",
                                             addmargins(table(df$comed_cat, df$mort_28, df$trt))[2,2,2], 
                                             addmargins(table(df$comed_cat, df$mort_28, df$trt))[2,3,2], 
                                             addmargins(table(df$comed_cat, df$mort_28, df$trt))[2,2,1], 
                                             addmargins(table(df$comed_cat, df$mort_28, df$trt))[2,3,1])
result_list[[15]] <- extract_subgroup_results(mort.28.sympdur.a10, "More than 10 days",
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[1,2,2], 
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[1,3,2], 
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[1,2,1], 
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[1,3,1])
result_list[[16]] <- extract_subgroup_results(mort.28.sympdur.510, "Between 5-10 days",
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[2,2,2], 
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[2,3,2], 
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[2,2,1], 
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[2,3,1])
result_list[[17]] <- extract_subgroup_results(mort.28.sympdur.b5, "5 days and less",
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[3,2,2], 
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[3,3,2], 
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[3,2,1], 
                                             addmargins(table(df$sympdur_cat, df$mort_28, df$trt))[3,3,1])
result_list[[18]] <- extract_subgroup_results(mort.28.crp.a75, "CRP 75 and higher",
                                             addmargins(table(df$crp_75, df$mort_28, df$trt))[1,2,2], 
                                             addmargins(table(df$crp_75, df$mort_28, df$trt))[1,3,2], 
                                             addmargins(table(df$crp_75, df$mort_28, df$trt))[1,2,1], 
                                             addmargins(table(df$crp_75, df$mort_28, df$trt))[1,3,1])
result_list[[19]] <- extract_subgroup_results(mort.28.crp.b75, "CRP below 75",
                                             addmargins(table(df$crp_75, df$mort_28, df$trt))[2,2,2], 
                                             addmargins(table(df$crp_75, df$mort_28, df$trt))[2,3,2], 
                                             addmargins(table(df$crp_75, df$mort_28, df$trt))[2,2,1], 
                                             addmargins(table(df$crp_75, df$mort_28, df$trt))[2,3,1])

# Filter out NULL results and bind the results into a single data frame
subgroup_df <- do.call(rbind, Filter(function(x) !is.null(x), result_list))

# Add the trial name and JAKi
subgroup_df$trial <- "COV-BARRIER"
subgroup_df$JAKi <- "Baricitinib"

# Nicely formatted table
kable(subgroup_df, format = "markdown", table.attr = 'class="table"') %>%
  kable_styling(bootstrap_options = "striped", full_width = FALSE)

# Save
saveRDS(subgroup_df, file = "subgroup_effects_cov-barrier.RData")
```
